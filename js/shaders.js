import { ShaderMaterial, Vector2, Vector3, Vector4 } from "./three.module.js";



export var opalShader = {
    vertexShader:([
        'varying vec3 vNormal;',
        'varying vec2 vUv;',
        'void main()',
        '{',
        ' vNormal = normal;',
        // 'position = 0.5 * position; ',
        ' gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
        '}',
    ]).join('\n'),
    fragmentShader : ([
        //this is based on https://www.shadertoy.com/view/4tcGDr
//         'uniform vec3      iResolution;',           // viewport resolution (in pixels)
//         'uniform float     iTime;',
//         'uniform vec4      iMouse;',               // shader playback time (in seconds)
//         'uniform vec3      eye;',               // Camera position
//         'uniform vec3      center;',               // Camera target
//         'uniform float     fov;',               // Camera target
//         'uniform vec2     mouse;',               // Camera target
//         'float Voronesque( in vec3 p )',
//         '{',
//         '    vec3 i  = floor(p+dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;',
//         '    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    ',
//         '    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;',
//         '    vec3 rnd = vec3(5.46,62.8,164.98); // my tuning',
//         '    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);',
//         '    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); ',
//         '    d = fract(sin(d)*1000.)*v*2.; ',
//         '    v.x = max(d.x, d.y), v.y = max(d.z, d.w); ',
//         '    return max(v.x, v.y);',
//         '}',
//         '',
//         'float df(vec3 p)',
//         '{',
//         '    float m = length(p) - 1.6;',
//         '	p.z += /*iTime **/ 0.82;',
//         '	return m + sqrt(Voronesque(p)*0.85);',
//         '}',
//         '',
//         'vec3 nor(vec3 p, float prec)',
//         '{',
//         '    vec2 e = vec2(-1.5, 1.5) * prec; ',
//         '    return normalize(e.yxx*df(p + e.yxx) + e.xxy*df(p + e.xxy) ',
//         '		+ e.xyx*df(p + e.xyx) + e.yyy*df(p + e.yyy) );',
//         '}',
//         '',
//         'vec3 shade(vec3 ro, vec3 rd, float d, vec3 v)',
//         '{',
//         '    vec3 p = ro + rd * d;',
//         '	vec3 np = normalize(p);			',
//         '	vec3 n = nor(p, 0.1);',
//         '	return (normalize(mix(vec3(max(0.,2.3-d)),np,0.28))',
//         '		* cross(vec3(5.0), reflect(rd, n)).brg * v.x',
//         '		+ pow(.15 + dot(n, np) * .66, 30.) * v.y) * v.z;',
//         '}',
//         '',
//         'void mainImage( out vec4 f, vec2 g )',
//         '{',
//         '    f.xyz = iResolution;',
//         '    g = (g+g-f.xy)/f.y;',
//         '    ',
//         '    float t = iTime * 0.5;',
//         '    ',
//         '    vec3 cu = vec3(0,1,0);',
//         '    vec3 ro = vec3(cos(t) * 2.,1.,sin(t) * 2.);',
//         '    vec3 co = vec3(0,0,0);',
//         '	',
//         '	float fov = 1.;',
//         '	vec3 axisZ = normalize(co - ro);',
//         '	vec3 axisX = normalize(cross(cu, axisZ));',
//         '	vec3 axisY = normalize(cross(axisZ, axisX));',
//         '	vec3 rd = normalize(axisZ + fov * g.x * axisX + fov * g.y * axisY);',
//         '    ',
//         '    vec3 p=ro, np, n, col, colss;',
//         '    ',
//         '    //f = texture(iChannel0, rd);',
//         '    ',
//         '    float d=0.,s=1.;',
//         '	',
//         '	for(int i=0;i<20;i++)',
//         '		if(s>0.0001 && d<2.)',
//         '			d+=s=df(ro+rd*d);',
//         '	',
//         '	// surface',
//         '    if (d<20.)',
//         '    {',
//         '		// surface color',
//         '        col = shade(ro, rd, d, vec3(.99,0.0,1));',
//         '        ',
//         '        // sub surface',
//         '        ro = ro+rd*d;',
//         '        d = 1.;',
//         '',
//         '        // sub surface color',
//         '        colss = shade(ro, rd, d, vec3(1,1,3));',
//         '        float ratio = 0.445;',
//         '		colss = clamp(colss, 0., 1./(1.-ratio));',
//         '        ',
//         '        ',
//         '		f.rgb = mix(col, colss, ratio);',
//         '	}',
//         '    vec3 color2 = vec3(1.,1.,1.0);',
//         '    vec3 color = vec3(0.2,0.5,0.85);',
//         '    f.rgb = mix(color, f.rgb, 0.2);',
//         '    f.rgb = mix(color2, f.rgb, 0.4);',
//         '}',
// 'void main() {',
// '    vec4 color;// = vec4(1.0,0.0,0.0,1.0);',
// '    mainImage(color, gl_FragCoord.xy);',
// '    gl_FragColor.xyz = color.xyz;',
// '}',

// '#version 330',
'',
//'out vec4 outColor;',
'',
// 'uniform vec2 iResolution;',
'uniform vec2      iResolution;', // viewport resolution (in pixels)
'uniform vec2 iMouse;',
// 'uniform vec2 mouse;',
'uniform float iTime;',
'',
'#define ROTATE false   ',
'#define flag true',
'',
'//---------------------------------------------------------',
'vec3 rotateX(vec3 p, float a) {',
'  float sa = sin(a);',
'  float ca = cos(a);',
'  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);',
'}',
'vec3 rotateY(vec3 p, float a) {',
'  float sa = sin(a);',
'  float ca = cos(a);',
'  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);',
'}',
'vec3 rotateZ(vec3 p, float a) {',
'  float sa = sin(a);',
'  float ca = cos(a);',
'  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);',
'}',
'',
'float length2(vec2 p)  // sqrt(x^2+y^2) ',
'{',
'  return sqrt(p.x * p.x + p.y * p.y);',
'}',
'',
'float length6(vec2 p)  // (x^6+y^6)^(1/6)',
'{',
'  p = p * p * p;',
'  p = p * p;',
'  return pow(p.x + p.y, 1.0 / 6.0);',
'}',
'',
'float length8(vec2 p)  // (x^8+y^8)^(1/8)',
'{',
'  p = p * p;',
'  p = p * p;',
'  p = p * p;',
'  return pow(p.x + p.y, 1.0 / 8.0);',
'}',
'',
'//---------------------------------------------------------',
'//  primitives',
'//---------------------------------------------------------',
'float sdPlane(vec3 p) {',
'  return p.y;',
'}',
'',
'float sdSphere(vec3 p, float radius) {',
'  return length(p) - radius;',
'}',
'',
'float sdWaveSphere(vec3 p, float radius, int waves, float waveSize) {	// deformation of radius',
'  float d = waveSize * (radius - length(p.y));',
'  radius += d * cos(atan(p.x, p.z) * float(waves));',
'  return length(p) - radius;',
'}',
'',
'float sdBox(vec3 p, vec3 b) {',
'  vec3 d = abs(p) - b;',
'  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));',
'}',
'',
'float udRoundBox(vec3 p, vec3 b, float r) {',
'  return length(max(abs(p) - b, 0.0)) - r;',
'}',
'',
'// t.x = torus radius,  t.y = ring radius',
'float sdTorus(vec3 p, vec2 t) {',
'  return length(vec2(length(p.xz) - t.x, p.y)) - t.y;',
'}',
'',
'float sdTorus82(vec3 p, vec2 t) {',
'  vec2 q = vec2(length2(p.xz) - t.x, p.y);',
'  return length8(q) - t.y;',
'}',
'',
'float sdTorus88(vec3 p, vec2 t) {',
'  vec2 q = vec2(length8(p.xz) - t.x, p.y);',
'  return length8(q) - t.y;',
'}',
'',
'float sdBlob(vec3 pos, float r) {',
'  vec3 v1 = pos * 6.0;',
'  return 0.05 * (r + 0.5 * (length(dot(v1, v1)) - 0.51 * (cos(4. * v1.x) + cos(4. * v1.y) + cos(4. * v1.z))));',
'}',
'',
'// Capsule:  a,b = end points, r = cylinder radius',
'float sdCapsule(vec3 p, vec3 a, vec3 b, float r) {',
'  vec3 pa = p - a, ba = b - a;',
'  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);',
'  return length(pa - ba * h) - r;',
'}',
'',
'// Triangle prism: ',
'float sdTriPrism(vec3 p, float radius, float height) {',
'  vec3 q = abs(p);',
'  #ifdef flag',
'  return max(q.z - height, max(q.x * 0.866025 + p.y * 0.5, -p.y) - radius * 0.5);',
'  #else',
'  float d1 = q.z - height;',
'  float d2 = max(q.x * 0.866025 + p.y * 0.5, -p.y) - radius * 0.5;',
'  return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);',
'  #endif',
'}',
'',
'// hexagonal prism:r ',
'float sdHexPrism(vec3 p, float radius, float height) {',
'  vec3 q = abs(p);',
'  #ifdef flag',
'  return max(q.z - height, max((q.x * 0.866025 + q.y * 0.5), q.y) - radius);',
'  #else',
'  float d1 = q.z - heighty;',
'  float d2 = max((q.x * 0.866025 + q.y * 0.5), q.y) - radius;',
'  return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);',
'  #endif',
'}',
'',
'float sdCylinder(vec3 p, vec2 h) {',
'  vec2 d = abs(vec2(length(p.xz), p.y)) - h;',
'  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));',
'}',
'',
'float sdCylinder(vec3 p, vec3 h) {',
'  return length(p.xz - h.xy) - h.z;',
'}',
'// h.xy = base rectangle size,  h.z = height',
'float sdCylinder6(vec3 p, vec3 h) {',
'  return max(length6(p.xz) - h.x, abs(p.y) - h.z);',
'}',
'',
'float sdCone(in vec3 p, in vec3 c) {',
'  vec2 q = vec2(length(p.xz), p.y);',
'  #if 0',
'  return max(max(dot(q, c.xy), p.y), -p.y - c.z);',
'  #else',
'  float d1 = -p.y - c.z;',
'  float d2 = max(dot(q, c.xy), p.y);',
'  return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);',
'  #endif',
'}',
'',
'//----------------------------------------------------------------------',
'// distance operations',
'//----------------------------------------------------------------------',
'',
'// Substraction: d1 -d2',
'float opS(float d1, float d2) {',
'  return max(-d2, d1);',
'}',
'',
'// Union: d1 +d2',
'vec2 opU(vec2 d1, vec2 d2) {',
'  return (d1.x < d2.x) ? d1 : d2;',
'}',
'',
'//----------------------------------------------------------------------',
'// domain operations',
'//----------------------------------------------------------------------',
'',
'// Repetition: ',
'vec3 opRep(vec3 p, vec3 c) {',
'  return mod(p, c) - 0.5 * c;',
'}',
'',
'// Twist: ',
'vec3 opTwist(vec3 p, float angle) {',
'  float c = cos(10.0 * p.y + angle);',
'  float s = sin(10.0 * p.y + angle);',
'  mat2 m = mat2(c, -s, s, c);',
'  return vec3(m * p.xz, p.y);',
'}',
'',
'//----------------------------------------------------------------------',
'// sphere cutted out from a rounded box',
'//----------------------------------------------------------------------',
'float sdBoxMinusSphere(vec3 pos, float radius) {',
'  return opS(udRoundBox(pos, vec3(0.15), 0.05), sdSphere(pos, radius - 0.012 + 0.02 * sin(iTime)));',
'}',
'//----------------------------------------------------------------------',
'// rack-wheel with holes',
'//----------------------------------------------------------------------',
'float sdRackWheel(vec3 pos) {',
'  return opS(sdTorus82(pos - vec3(-2.0, 0.2, 0.0), vec2(0.20, 0.1)), sdCylinder(opRep(vec3(atan(pos.x + 2.0, pos.z) / 6.2831 + 0.1 * iTime, pos.y, 0.02 + 0.5 * length(pos - vec3(-2.0, 0.2, 0.0))), vec3(0.05, 1.0, 0.05)), vec2(0.02, 0.6)));',
'}',
'//----------------------------------------------------------------------',
'float sdBallyBall(vec3 pos) {',
'  return 0.7 * sdSphere(pos, 0.2) + 0.03 * sin(50.0 * pos.x) * sin(50.0 * pos.y + 8.0 * iTime) * sin(50.0 * pos.z);',
'}',
'//----------------------------------------------------------------------',
'float sdTwistedTorus(vec3 pos, float angle) {',
'  return 0.5 * sdTorus(opTwist(pos, angle), vec2(0.20, 0.05));',
'}',
'//----------------------------------------------------------------------',
'vec2 map(vec3 pos) {',
'  vec3 r1, r2;',
'  float sphy = 0.35 + 0.1 * sin(iTime);',
'  vec3 sp = pos - vec3(1.0, sphy, 0.0);',
'  vec2 res = vec2(sdPlane(pos), 1.0); ',
'  vec2 mo = iMouse.xy;',
'  // res = opU( res, vec2( sdSphere(    sp, 0.25 ), 46.9 ) );',
'  // res = opU(res, vec2(sdBlob(pos - vec3(0.0, 0.25, 0.0), -0.5 - 0.45 * sin(iTime)), 246.9));',
'',
'  // res = opU(res, vec2(sdBox(pos - vec3(1.0, 0.25, 0.0), vec3(0.20)), 3.0));',
'  // res = opU(res, vec2(udRoundBox(pos - vec3(1.0, 0.25, 1.0), vec3(0.12), 0.1), 41.0));',
'  // r1 = rotateX(pos - vec3(0.0, 0.25, 1.0), 1.0);',
'  // r1 = rotateX(vec3(1.0, 0.0, 0.0), 0.2);',
'  // r1 = rotateY(r1, iTime * 0.2);',
'  // res = opU(res, vec2(sdTorus(r1, vec2(0.20, 0.05)), 25.0));',
'  // r1 = vec3(2.0, 0.5, 0.4);//+ rotateY(vec3(-0.15, 0.0, -0.15), 0.0);',
'  // r2 = vec3(2.0, 0.5, 0.3);//+ rotateY(vec3(-0.15, 0.0, -0.15), 0.0);',
'  // res = opU(res, vec2(sdCapsule(pos, r1, r2, .1), 31.9));',
'',
'  // r1 = vec3(1.95, 0.5, 0.35) ;',
'  // r2 = vec3(2.05, 0.5, 0.35) ;',
'  ',
'  // res = opU(res, vec2(sdCapsule(pos, r1, r2, .1), 31.9));',
'',
'',
'  r1 = vec3(2.2, 0.5, 0.35) ;',
'  r2 = vec3(2.2, 0.5, 0.35) ;',
'  res = opU(res, vec2(sdCapsule(pos, r1, r2, .05), 31.9));',
'',
'',
'  r1 = vec3(1.81, 0.5, 0.29) ;',
'  r2 = vec3(1.81, 0.5, 0.29) ;',
'  res = opU(res, vec2(sdCapsule(pos, r1, r2, .05), 31.9));',
'',
'',
'  r1 = vec3(1.81, 0.5, 0.38);',
'  r2 = vec3(1.81, 0.5, 0.38);',
'  res = opU(res, vec2(sdCapsule(pos, r1, r2, .05), 31.9));',
'',
'',
'  res = opU(res, vec2(sdTorus((pos - vec3(2.0, 0.5, 0.35)), vec2(0.12, 0.05)), 31.9));  ',
'  // r1 = vec3(2.0, 0.2, 0.2) ;',
'  // r2 = vec3(2.0, 0.5, -0.2) ;',
'  // res = opU(res, vec2(sdCapsule(pos, r1, r2, .1), 31.9));',
'',
'  // r1 = vec3(2.0, 0.2, 0.2) ;',
'  // r2 = vec3(2.0, 0.5, -0.2) ;',
'  // res = opU(res, vec2(sdCapsule(pos, r1, r2, .1), 31.9));',
'',
'  // res = opU(res, vec2(sdTriPrism(pos - vec3(-1.0, 0.25, -1.0), 0.1 * sin(iTime) + 0.25, 0.05), 43.5));',
'  // float h1 = 0.2;//0.2 + 0.06 * sin(iTime);',
'  // res = opU(res, vec2(sdCylinder(pos - vec3(2.0, .5, 0.5), vec2(0.2, h1+0.5)), 8.0));',
'  // vec3 posC = pos.xyz +vec3( -2, 0.0, 0.0);',
'  // r1 = rotateY(vec3(.20,1.0,.0) ,10);',
'  // res = opU(res, vec2(sdCylinder(posC - r1, vec2(0.5, h1)), 2.0));',
'  // res = opU(res, vec2(sdCone(pos - vec3(0.0, 0.50, -1.0), vec3(0.8, 0.5 + 0.1 * sin(iTime), 0.3)), 55.0));',
'  // res = opU(res, vec2(sdTorus82(pos - vec3(0.0, 0.25, 2.0), vec2(0.20, 0.05)), 50.0));',
'  // r1 = rotateY(pos - vec3(-1.0, 0.25, 2.0), iTime * 0.25);',
'  // res = opU(res, vec2(sdTorus88(r1, vec2(0.20, 0.05)), 43.0));',
'  // r1 = rotateY(pos - vec3(1.0, 0.30, 2.0), iTime * 0.25);',
'  // res = opU(res, vec2(sdCylinder6(r1, vec3(0.1, 0.05, 0.25)), 12.0));',
'  // r1 = rotateX(pos - vec3(-1.0, 0.25, 1.0), iTime * 0.5);',
'  // res = opU(res, vec2(sdHexPrism(r1, 0.25, 0.05), 17.0));',
'  // res = opU(res, vec2(sdBoxMinusSphere(pos - vec3(-2.0, 0.2, 1.0), 0.25), 13.0));',
'  // res = opU(res, vec2(sdRackWheel(pos), 51.0));',
'  // res = opU(res, vec2(sdTwistedTorus(pos - vec3(-2.0, 0.25, 2.0), 6.0 * sin(iTime)), 46.7));',
'  // res = opU(res, vec2(sdWaveSphere(pos - vec3(-2.0, 0.25, -1.0), 0.2, 10, sin(iTime) * 0.2), 880));',
'// res = opU( res, vec2( sdBallyBall   ( pos - vec3(-2.0, 0.25, -1.0)), 65.0 ) );',
'  return res;',
'}',
'',
'//----------------------------------------------------------------------',
'vec2 castRay(vec3 ro, vec3 rd) {',
'  float tmin = 1.0;',
'  float tmax = 20.0;',
'',
'  #if 0',
'  float tp1 = (0.0 - ro.y) / rd.y;',
'  if(tp1 > 0.0)',
'    tmax = min(tmax, tp1);',
'  float tp2 = (1.6 - ro.y) / rd.y;',
'  if(tp2 > 0.0) {',
'    if(ro.y > 1.6)',
'      tmin = max(tmin, tp2);',
'    else',
'      tmax = min(tmax, tp2);',
'  }',
'  #endif',
'',
'  float precis = 0.002;',
'  float t = tmin;',
'  float m = -1.0;',
'  for(int i = 0; i < 60; i++) {',
'    vec2 res = map(ro + (rd) * t);',
'    if(res.x < precis || t > tmax)',
'      break;',
'    t += res.x;',
'    m = res.y;',
'  }',
'',
'  if(t > tmax)',
'    m = -1.0;',
'  return vec2(t, m);',
'}',
'',
'//----------------------------------------------------------------------',
'float softshadow(vec3 ro, vec3 rd, float mint, float tmax) {',
'  float res = 1.0;',
'  float t = mint;',
'  for(int i = 0; i < 8; i += 1) {',
'    float h = map(ro + rd * t).x;',
'    res = min(res, 8.0 * h / t);',
'    t += clamp(h, 0.02, 0.10);',
'    if(h < 0.001 || t > tmax)',
'      break;',
'  }',
'  return clamp(res, 0.0, 1.0);',
'}',
'',
'//----------------------------------------------------------------------',
'vec3 calcNormal(vec3 pos) {',
'  vec3 eps = vec3(0.001, 0.0, 0.0);',
'  vec3 nor = vec3(map(pos + eps.xyy).x - map(pos - eps.xyy).x, map(pos + eps.yxy).x - map(pos - eps.yxy).x, map(pos + eps.yyx).x - map(pos - eps.yyx).x);',
'  return normalize(nor);',
'}',
'',
'//----------------------------------------------------------------------',
'float calcAO(vec3 pos, vec3 nor) {',
'  float occ = 0.0;',
'  float sca = 1.0;',
'  for(int i = 0; i < 5; i++) {',
'    float hr = 0.01 + 0.12 * float(i) / 4.0;',
'    vec3 aopos = nor * hr + pos;',
'    float dd = map(aopos).x;',
'    occ += -(dd - hr) * sca;',
'    sca *= 0.95;',
'  }',
'  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);',
'}',
'//---------------------------------------------------------',
// 'vec3 render(vec3 ro, vec3 rd) {',
// '  vec3 col = vec3(0.8, 0.9, 1.0);',
// '  vec2 res = castRay(ro, rd);',
// '  float t = res.x;',
// '  float m = res.y;',
// '  if(m > -0.5) {',
// '    vec3 pos = ro + t * rd;',
// '    vec3 nor = calcNormal(pos);',
// '    vec3 ref = reflect(rd, nor);',
// '',
// '    // material        ',
// '    col = 0.45 + 0.3 * sin(vec3(0.05, 0.08, 0.10) * (m - 1.0));',
// '',
// '    if(m < 1.5) {',
// '      float f = mod(floor(5.0 * pos.z) + floor(5.0 * pos.x), 2.0);',
// '      col = 0.4 + 0.1 * f * vec3(1.0);',
// '    }',
// '',
// '    // lighting        ',
// '    float occ = calcAO(pos, nor);',
// '    vec3 lig = normalize(vec3(-0.6, 0.7, -0.5));',
// '    float amb = clamp(0.8 + 0.8 * nor.y, 0.8, 1.0);',
// '    float dif = clamp(dot(nor, lig), 0.5,1.0);',
// '    float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0);',
// '    float dom = smoothstep(-50, -50, ref.y);',
// '    float fre = pow(clamp(0.5 + dot(nor, rd), 0.90, 1.0), 2.0);',
// '    float spe = pow(clamp(dot(ref, lig), 0.5, 1.0), 18.0);',
// '',
// '    dif *= softshadow(pos, lig, 0.02, 2.5);',
// '    dom *= softshadow(pos, ref, 0.2, 2.5);',
// '',
// '    vec3 brdf = vec3(0.0);',
// '    brdf += 1.20 * dif * vec3(1.00, 0.90, 0.60);',
// '    brdf += 1.20 * spe * vec3(1.00, 0.90, 0.60) * dif;',
// '    brdf += 0.30 * amb * vec3(0.50, 0.70, 1.00) * occ;',
// '    brdf += 0.40 * dom * vec3(0.50, 0.70, 1.00) * occ;',
// '    brdf += 0.30 * bac * vec3(0.25, 0.25, 0.25) * occ;',
// '    brdf += 0.40 * fre * vec3(1.00, 1.00, 1.00) * occ;',
// '    brdf += 0.02;',
// '    col = col * brdf;',
// '    col = mix(col, vec3(0.8, 0.9, 1.0), 1.0 - exp(-0.005 * t * t));',
// '  }',
// '  return vec3(clamp(col, 0.0, 1.0));',
// '}',
'',
'// Created by Stephane Cuillerdier - @Aiekick/2016',
'// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.',
'// Tuned via XShade (http://www.funparadigm.com/xshade/)',
'',
'// by shane',
'float Voronesque( in vec3 p )',
'{',
'    vec3 i  = floor(p+dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;',
'    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    ',
'    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;',
'    vec3 rnd = vec3(5.46,62.8,164.98); // my tuning',
'    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);',
'    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); ',
'    d = fract(sin(d)*1000.)*v*2.; ',
'    v.x = max(d.x, d.y), v.y = max(d.z, d.w); ',
'    return max(v.x, v.y);',
'}',
'',
'float df(vec3 p)',
'{',
'    float m = length(p) - 1.6;',
'	p.z += /*iTime **/ 0.82;',
'	return m + sqrt(Voronesque(p)*0.85);',
'}',
'',
'vec3 nor(vec3 p, float prec)',
'{',
'    vec2 e = vec2(-1.5, 1.5) * prec; ',
'    return normalize(e.yxx*df(p + e.yxx) + e.xxy*df(p + e.xxy) ',
'		+ e.xyx*df(p + e.xyx) + e.yyy*df(p + e.yyy) );',
'}',
'',
'vec3 shade(vec3 ro, vec3 rd, float d, vec3 v)',
'{',
'    vec3 p = ro + rd * d;',
'	vec3 np = normalize(p);			',
'	vec3 n = nor(p, 0.1);',
'	return (normalize(mix(vec3(max(0.,2.3-d)),np,0.28))',
'		* cross(vec3(5.0), reflect(rd, n)).brg * v.x',
'		+ pow(.15 + dot(n, np) * .66, 30.) * v.y) * v.z;',
'}',
'',
'void mainImage( out vec4 f, vec2 g )',
'{',
'    //f.xy = iResolution.xy/iResolution.y;',
'    g = (g*0.005);///iResolution.y;//(g-2.0*f.xy)/f.y;',
'    ',
// '    iTime =1.0;',
// '    float t = 0.0 * 0.5;',
'    float tt = clamp(abs(cameraPosition.y+cameraPosition.x),0.1,100.0) * 0.20;',
'    ',
'    vec3 cu = vec3(0.0,1.0,0.0);',
// '    vec3 ro = vec3(0.5 * 100.,100.,0.5 * 200.);//vec3(/*cos(t) * */20.,10.,/*sin(t) **/ 10.);',
'    vec3 ro = vec3((cos(tt)) *1.,10.,(sin(tt)) * 10.);',
// '    vec3 ro = vec3((5.0+10.0),5.,5.0+ 10.);',
'    vec3 co = vec3(0.,0.,0.);',
'	',
'	float fov = 1.;',
'	vec3 axisZ = normalize(co - ro);',
'	vec3 axisX = normalize(cross(cu, axisZ));',
'	vec3 axisY = normalize(cross(axisZ, axisX));',
'	vec3 rd = normalize(axisZ + fov * g.x * axisX + fov * g.y * axisY);',
'    ',
'    vec3 p=ro, np, n, col, colss;',
'    ',
'    //f = texture(iChannel0, rd);',
'    ',
'    float d=0.01,s=2.0;',
'	',
'	for(int i=0;i<150;i++)',
'		if(s>0.1 && d<.02)',
'			d+=s=df(ro+rd*d);',
'	',
// '    vec3 color ;',
'    float ff = 0.350;',
'	// surface',
'    if (d<250.)',
'    {',
// '       col = vec3(0.2,0.5,0.85);',
'		// surface color',
'        col = shade(ro, rd, d, vec3(0.9,0.0,1));',
// '        col = shade(ro, rd, d, vec3(.9,0.0,1));',
'        ',
'        // sub surface',
'        ro = ro+rd*d;',
'        d = 1.;',
'',
'        // sub surface color',
'        colss = shade(ro, rd, d, vec3(1,1,3));',
'        float ratio = 0.45;',
'		colss = clamp(colss, 0., 1./(1.-ratio));',
'        ',
'        ',
'		f.rgb = mix(col, colss, ratio);',
'       ff= clamp(dot(cameraPosition-rd,cameraPosition-d), 0.3, 0.5);',
'	}',
// '   else{',
// '       color = vec3(0.9,0.0,0.);',
// '   }',

'    vec3 color2 = vec3(1.,1.,1.0);',
'    vec3 color = vec3(0.2,0.5,0.95);',
'    f.rgb = mix(color, f.rgb, 0.35);',
'    f.rgb = mix(color2, f.rgb, 0.3);',
'}',
'',
'//---------------------------------------------------------',
'void main() {',
'  // pixel color',
'  //vec3 col = render(ro, rd);',
'  vec4 col;',
'  vec3 color;',
'  mainImage( col, gl_FragCoord.xy );',
'  color = col.xyz;',
// '  color = pow(color, vec3(.4545));',
'  gl_FragColor = vec4(color, 1.0);',
'}',
    ]).join('\n'),
    uniforms : {
        "iResolution" : {value : new Vector3()},
        "iTime" : {value : 0.0,type: "f"},
        "fov" : {value : 75},
        "iMouse" : {value : new Vector2()},
        "eye" : {value : new Vector3()},
        "center" : {value : new Vector3()},
        // "mouse" : {value: new Vector2()},
    }
}

export var M_opal = new ShaderMaterial({
    vertexShader: opalShader.vertexShader,
    fragmentShader:opalShader.fragmentShader,
    uniforms:opalShader.uniforms,
});

