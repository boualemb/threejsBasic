import { ShaderMaterial, Vector2, Vector3, Vector4 } from "./three.module.js";



export var opalShader = {
    vertexShader:([
        'varying vec3 vNormal;',
        'varying vec2 vUv;',
        'uniform vec3 eye;',
        'mat4 rotationMatrix(vec3 axis, float angle)',
        '{',
        '    axis = normalize(axis);',
        '    float s = sin(angle);',
        '    float c = cos(angle);',
        '    float oc = 1.0 - c;',
        '    ',
        '    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,',
        '                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,',
        '                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,',
        '                0.0,                                0.0,                                0.0,                                1.0);',
        '}',
        'void main()',
        '{',
        ' vNormal = normal;',
        '    vec3 position_t = (rotationMatrix(vec3(1.0, 0.0, 0.0), -3.14/2.0) * vec4(position,1.0)).xyz;',
         //'position = rotationMatrix(1.0,0.0,0.0,3.14/2.0) * vec4(position,1.0); ',
        ' gl_Position = projectionMatrix * modelViewMatrix * vec4( position_t, 1.0 );',
        '}',
    ]).join('\n'),
    fragmentShader : ([
        'varying vec3 vNormal;',
        'varying vec2 vUv;',
        //this is based on https://www.shadertoy.com/view/4tcGDr
        'uniform vec3      iResolution;',           // viewport resolution (in pixels)
        'uniform float     iTime;',
        'uniform vec4      iMouse;',               // shader playback time (in seconds)
        'uniform vec3      eye;',               // Camera position
        'uniform vec3      center;',               // Camera target
        'uniform float     fov;',               // Camera target
        'uniform vec2     mouse;',               // Camera target
        'uniform float     alpha1;',               // Camera target
        'uniform float     alpha2;',               // Camera target
        'uniform float     alpha3;',               // Camera target
        'uniform float     alpha4;',               // Camera target
        'uniform float     alpha5;',               // Camera target
        'uniform float     alpha6;',               // Camera target
        'uniform float     w1;',               // cloud
        'uniform float     w2;',               // cloud
        'uniform float     b1;',               // cloud
        'uniform float     b2;',               // cloud
        'uniform vec3     color_cloud;',       // cloud
        'uniform float     alpha_cloud;',      // cloud
//         'float Voronesque( in vec3 p )',
//         '{',
//         '    vec3 i  = floor(p+dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;',
//         '    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    ',
//         '    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;',
//         '    vec3 rnd = vec3(5.46,62.8,164.98); // my tuning',
//         '    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);',
//         '    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); ',
//         '    d = fract(sin(d)*1000.)*v*2.; ',
//         '    v.x = max(d.x, d.y), v.y = max(d.z, d.w); ',
//         '    return max(v.x, v.y);',
//         '}',
//         '',
//         'float df(vec3 p)',
//         '{',
//         '    float m = length(p) - 1.6;',
//         '	p.z += /*iTime **/ 0.82;',
//         '	return m + sqrt(Voronesque(p)*0.85);',
//         '}',
//         '',
//         'vec3 nor(vec3 p, float prec)',
//         '{',
//         '    vec2 e = vec2(-1.5, 1.5) * prec; ',
//         '    return normalize(e.yxx*df(p + e.yxx) + e.xxy*df(p + e.xxy) ',
//         '		+ e.xyx*df(p + e.xyx) + e.yyy*df(p + e.yyy) );',
//         '}',
//         '',
//         'vec3 shade(vec3 ro, vec3 rd, float d, vec3 v)',
//         '{',
//         '    vec3 p = ro + rd * d;',
//         '	vec3 np = normalize(p);			',
//         '	vec3 n = nor(p, 0.1);',
//         '	return (normalize(mix(vec3(max(0.,2.3-d)),np,0.28))',
//         '		* cross(vec3(5.0), reflect(rd, n)).brg * v.x',
//         '		+ pow(.15 + dot(n, np) * .66, 30.) * v.y) * v.z;',
//         '}',
//         '',
//         'void mainImage( out vec4 f, vec2 g )',
//         '{',
//         '    f.xyz = iResolution;',
//         '    g = (g+g-f.xy)/f.y;',
//         '    ',
//         '    float t = iTime * 0.5;',
//         '    ',
//         '    vec3 cu = vec3(0,1,0);',
//         '    vec3 ro = vec3(cos(t) * 2.,1.,sin(t) * 2.);',
//         '    vec3 co = vec3(0,0,0);',
//         '	',
//         '	float fov = 1.;',
//         '	vec3 axisZ = normalize(co - ro);',
//         '	vec3 axisX = normalize(cross(cu, axisZ));',
//         '	vec3 axisY = normalize(cross(axisZ, axisX));',
//         '	vec3 rd = normalize(axisZ + fov * g.x * axisX + fov * g.y * axisY);',
//         '    ',
//         '    vec3 p=ro, np, n, col, colss;',
//         '    ',
//         '    //f = texture(iChannel0, rd);',
//         '    ',
//         '    float d=0.,s=1.;',
//         '	',
//         '	for(int i=0;i<20;i++)',
//         '		if(s>0.0001 && d<2.)',
//         '			d+=s=df(ro+rd*d);',
//         '	',
//         '	// surface',
//         '    if (d<20.)',
//         '    {',
//         '		// surface color',
//         '        col = shade(ro, rd, d, vec3(.99,0.0,1));',
//         '        ',
//         '        // sub surface',
//         '        ro = ro+rd*d;',
//         '        d = 1.;',
//         '',
//         '        // sub surface color',
//         '        colss = shade(ro, rd, d, vec3(1,1,3));',
//         '        float ratio = 0.445;',
//         '		colss = clamp(colss, 0., 1./(1.-ratio));',
//         '        ',
//         '        ',
//         '		f.rgb = mix(col, colss, ratio);',
//         '	}',
//         '    vec3 color2 = vec3(1.,1.,1.0);',
//         '    vec3 color = vec3(0.2,0.5,0.85);',
//         '    f.rgb = mix(color, f.rgb, 0.2);',
//         '    f.rgb = mix(color2, f.rgb, 0.4);',
//         '}',
// 'void main() {',
// '    vec4 color;// = vec4(1.0,0.0,0.0,1.0);',
// '    mainImage(color, gl_FragCoord.xy);',
// '    gl_FragColor.xyz = color.xyz;',
// '}',

// '#version 330',
'',
//'out vec4 outColor;',
'',
// 'uniform vec2 iResolution;',
// 'uniform vec2      iResolution;', // viewport resolution (in pixels)
// 'uniform vec2 iMouse;',
// 'uniform vec2 mouse;',
// 'uniform float iTime;',
'',
'#define ROTATE false   ',
'#define flag true',
'',

'mat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}',
'const mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.93;',
'float mag2(vec2 p){return dot(p,p);}',
'float linstep(in float mn, in float mx, in float x){ return clamp((x - mn)/(mx - mn), 0., 1.); }',
'float prm1 = 0.;',
'vec2 bsMo = vec2(0);',
'',
'vec2 disp(float t){ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; }',
'',
'vec2 map(vec3 p)',
'{',
'    vec3 p2 = p;',
'    p2.xy -= disp(p.x).yx;',
'    p.xy *= rot(sin(p.x+0.2)*(0.1 + prm1*0.05) + 0.93*0.9);',
'    float cl = mag2(p2.xy);',
'    float d = 0.;',
'    p *= .91;',
'    float z = 1.;',
'    float trk = 1.;',
'    float dspAmp = .51 + prm1*0.82;',
'    for(int i = 0; i < 5; i++)',
'    {',
'		p += sin(p.zxy*0.275*trk + 0.1*trk*.8)*dspAmp;',
'        d -= abs(dot(cos(p), sin(p.yzx))*z);',
'        z *= 0.57;',
'        trk *= 1.24;',
'        p = p*m3;',
'    }',
'    d = abs(d + prm1*3.)+ prm1*.3 - 2.5 + bsMo.y;',
'    return vec2(d + cl*.2 + 0.25, cl);',
'}',
'',
'vec4 render( in vec3 ro, in vec3 rd, float time )',
'{',
'	vec4 rez = vec4(0);',
'    const float ldst = 8.;',
'	vec3 lpos = vec3(disp(time + ldst)*0.5, time + ldst);',
'	float t = 1.5;',
'	float fogT = 0.;',
'	for(int i=0; i<50; i++)',
'	{',
'		if(rez.a > 0.49)break;',
'',
'		vec3 pos = ro + t*rd;',
'        vec2 mpv = map(pos);',
'		float den = clamp(mpv.x-0.3,0.,1.)*1.12;',
'		float dn = clamp((mpv.x + 2.),0.,3.);',
'        ',
'		vec4 col = vec4(0);',
'        if (mpv.x > 0.6)',
'        {',
'        ',
'            col = vec4(sin(vec3(1.,1.0,1.0) + mpv.y*1.51 +sin(pos.z*0.94)*0.5 + 1.28)*0.5 + 0.5,0.98);',
'            col *= den*den*den;',
'			col.rgb *= linstep(4.,-2.5, mpv.x)*2.3;',
'            float dif =  clamp((den - map(pos+.8).x)/9., 0.001, 1. );',
'            dif += clamp((den - map(pos+.35).x)/2.5, 0.001, 1. );',
'            col.xyz *= den*(vec3(0.005,.045,.075) + 1.5*vec3(0.033,0.07,0.03)*dif);',
'        }',
'		',
'		float fogC = exp(t*0.2 - 2.2);',
'		col.rgba += vec4(0.06,0.11,0.11, 0.1)*clamp(fogC-fogT, 0., 1.);',
'		fogT = fogC;',
'		rez = rez + col*(1. - rez.a);',
'		t += clamp(0.5 - dn*dn*.05, 0.09, 0.3);',
'	}',
'	return clamp(rez, 0.0, 1.0);',
'}',
'',
'float getsat(vec3 c)',
'{',
'    float mi = min(min(c.x, c.y), c.z);',
'    float ma = max(max(c.x, c.y), c.z);',
'    return (ma - mi)/(ma+ 1e-7);',
'}',
'',
'//from my "Will it blend" shader (https://www.shadertoy.com/view/lsdGzN)',
'vec3 iLerp(in vec3 a, in vec3 b, in float x)',
'{',
'    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,0.);',
'    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));',
'    vec3 dir = normalize(vec3(2.*ic.x - ic.y - ic.z, 2.*ic.y - ic.x - ic.z, 2.*ic.z - ic.y - ic.x));',
'    float lgt = dot(vec3(1.0), ic);',
'    float ff = dot(dir, normalize(ic));',
'    ic += 1.5*dir*sd*ff*lgt;',
'    return clamp(ic,0.,1.);',
'}',
'//---------------------------------------------------------',
'vec3 rotateX(vec3 p, float a) {',
'  float sa = sin(a);',
'  float ca = cos(a);',
'  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);',
'}',
'vec3 rotateY(vec3 p, float a) {',
'  float sa = sin(a);',
'  float ca = cos(a);',
'  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);',
'}',
'vec3 rotateZ(vec3 p, float a) {',
'  float sa = sin(a);',
'  float ca = cos(a);',
'  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);',
'}',
'',
'float length2(vec2 p)  // sqrt(x^2+y^2) ',
'{',
'  return sqrt(p.x * p.x + p.y * p.y);',
'}',
'',
'float length6(vec2 p)  // (x^6+y^6)^(1/6)',
'{',
'  p = p * p * p;',
'  p = p * p;',
'  return pow(p.x + p.y, 1.0 / 6.0);',
'}',
'',
'float length8(vec2 p)  // (x^8+y^8)^(1/8)',
'{',
'  p = p * p;',
'  p = p * p;',
'  p = p * p;',
'  return pow(p.x + p.y, 1.0 / 8.0);',
'}',
'',
'//---------------------------------------------------------',
'//  primitives',
'//---------------------------------------------------------',
'float sdPlane(vec3 p) {',
'  return p.y;',
'}',
'',
'float sdSphere(vec3 p, float radius) {',
'  return length(p) - radius;',
'}',
'',
'float sdWaveSphere(vec3 p, float radius, int waves, float waveSize) {	// deformation of radius',
'  float d = waveSize * (radius - length(p.y));',
'  radius += d * cos(atan(p.x, p.z) * float(waves));',
'  return length(p) - radius;',
'}',
'',
'float sdBox(vec3 p, vec3 b) {',
'  vec3 d = abs(p) - b;',
'  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));',
'}',
'',
'float udRoundBox(vec3 p, vec3 b, float r) {',
'  return length(max(abs(p) - b, 0.0)) - r;',
'}',
'',
'// t.x = torus radius,  t.y = ring radius',
'float sdTorus(vec3 p, vec2 t) {',
'  return length(vec2(length(p.xz) - t.x, p.y)) - t.y;',
'}',
'',
'float sdTorus82(vec3 p, vec2 t) {',
'  vec2 q = vec2(length2(p.xz) - t.x, p.y);',
'  return length8(q) - t.y;',
'}',
'',
'float sdTorus88(vec3 p, vec2 t) {',
'  vec2 q = vec2(length8(p.xz) - t.x, p.y);',
'  return length8(q) - t.y;',
'}',
'',
'float sdBlob(vec3 pos, float r) {',
'  vec3 v1 = pos * 6.0;',
'  return 0.05 * (r + 0.5 * (length(dot(v1, v1)) - 0.51 * (cos(4. * v1.x) + cos(4. * v1.y) + cos(4. * v1.z))));',
'}',
'',
'// Capsule:  a,b = end points, r = cylinder radius',
'float sdCapsule(vec3 p, vec3 a, vec3 b, float r) {',
'  vec3 pa = p - a, ba = b - a;',
'  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);',
'  return length(pa - ba * h) - r;',
'}',
'',
'// Triangle prism: ',
'float sdTriPrism(vec3 p, float radius, float height) {',
'  vec3 q = abs(p);',
'  #ifdef flag',
'  return max(q.z - height, max(q.x * 0.866025 + p.y * 0.5, -p.y) - radius * 0.5);',
'  #else',
'  float d1 = q.z - height;',
'  float d2 = max(q.x * 0.866025 + p.y * 0.5, -p.y) - radius * 0.5;',
'  return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);',
'  #endif',
'}',
'',
'// hexagonal prism:r ',
'float sdHexPrism(vec3 p, float radius, float height) {',
'  vec3 q = abs(p);',
'  #ifdef flag',
'  return max(q.z - height, max((q.x * 0.866025 + q.y * 0.5), q.y) - radius);',
'  #else',
'  float d1 = q.z - heighty;',
'  float d2 = max((q.x * 0.866025 + q.y * 0.5), q.y) - radius;',
'  return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);',
'  #endif',
'}',
'',
'float sdCylinder(vec3 p, vec2 h) {',
'  vec2 d = abs(vec2(length(p.xz), p.y)) - h;',
'  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));',
'}',
'',
'float sdCylinder(vec3 p, vec3 h) {',
'  return length(p.xz - h.xy) - h.z;',
'}',
'// h.xy = base rectangle size,  h.z = height',
'float sdCylinder6(vec3 p, vec3 h) {',
'  return max(length6(p.xz) - h.x, abs(p.y) - h.z);',
'}',
'',
'float sdCone(in vec3 p, in vec3 c) {',
'  vec2 q = vec2(length(p.xz), p.y);',
'  #if 0',
'  return max(max(dot(q, c.xy), p.y), -p.y - c.z);',
'  #else',
'  float d1 = -p.y - c.z;',
'  float d2 = max(dot(q, c.xy), p.y);',
'  return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);',
'  #endif',
'}',
'',
'//----------------------------------------------------------------------',
'// distance operations',
'//----------------------------------------------------------------------',
'',
'// Substraction: d1 -d2',
'float opS(float d1, float d2) {',
'  return max(-d2, d1);',
'}',
'',
'// Union: d1 +d2',
'vec2 opU(vec2 d1, vec2 d2) {',
'  return (d1.x < d2.x) ? d1 : d2;',
'}',
'',
'//----------------------------------------------------------------------',
'// domain operations',
'//----------------------------------------------------------------------',
'',
'// Repetition: ',
'vec3 opRep(vec3 p, vec3 c) {',
'  return mod(p, c) - 0.5 * c;',
'}',
'',
'// Twist: ',
'vec3 opTwist(vec3 p, float angle) {',
'  float c = cos(10.0 * p.y + angle);',
'  float s = sin(10.0 * p.y + angle);',
'  mat2 m = mat2(c, -s, s, c);',
'  return vec3(m * p.xz, p.y);',
'}',
'',
'//----------------------------------------------------------------------',
'// sphere cutted out from a rounded box',
'//----------------------------------------------------------------------',
'float sdBoxMinusSphere(vec3 pos, float radius) {',
'  return opS(udRoundBox(pos, vec3(0.15), 0.05), sdSphere(pos, radius - 0.012 + 0.02 * sin(iTime)));',
'}',
'//----------------------------------------------------------------------',
'// rack-wheel with holes',
'//----------------------------------------------------------------------',
'float sdRackWheel(vec3 pos) {',
'  return opS(sdTorus82(pos - vec3(-2.0, 0.2, 0.0), vec2(0.20, 0.1)), sdCylinder(opRep(vec3(atan(pos.x + 2.0, pos.z) / 6.2831 + 0.1 * iTime, pos.y, 0.02 + 0.5 * length(pos - vec3(-2.0, 0.2, 0.0))), vec3(0.05, 1.0, 0.05)), vec2(0.02, 0.6)));',
'}',
'//----------------------------------------------------------------------',
'float sdBallyBall(vec3 pos) {',
'  return 0.7 * sdSphere(pos, 0.2) + 0.03 * sin(50.0 * pos.x) * sin(50.0 * pos.y + 8.0 * iTime) * sin(50.0 * pos.z);',
'}',
'//----------------------------------------------------------------------',
'float sdTwistedTorus(vec3 pos, float angle) {',
'  return 0.5 * sdTorus(opTwist(pos, angle), vec2(0.20, 0.05));',
'}',
'//----------------------------------------------------------------------',
'vec2 map1(vec3 pos) {',
'  vec3 r1, r2;',
'  float sphy = 0.35 + 0.1 * sin(iTime);',
'  vec3 sp = pos - vec3(1.0, sphy, 0.0);',
'  vec2 res = vec2(sdPlane(pos), 1.0); ',
'  vec2 mo = iMouse.xy;',
'  // res = opU( res, vec2( sdSphere(    sp, 0.25 ), 46.9 ) );',
'  // res = opU(res, vec2(sdBlob(pos - vec3(0.0, 0.25, 0.0), -0.5 - 0.45 * sin(iTime)), 246.9));',
'',
'  // res = opU(res, vec2(sdBox(pos - vec3(1.0, 0.25, 0.0), vec3(0.20)), 3.0));',
'  // res = opU(res, vec2(udRoundBox(pos - vec3(1.0, 0.25, 1.0), vec3(0.12), 0.1), 41.0));',
'  // r1 = rotateX(pos - vec3(0.0, 0.25, 1.0), 1.0);',
'  // r1 = rotateX(vec3(1.0, 0.0, 0.0), 0.2);',
'  // r1 = rotateY(r1, iTime * 0.2);',
'  // res = opU(res, vec2(sdTorus(r1, vec2(0.20, 0.05)), 25.0));',
'  // r1 = vec3(2.0, 0.5, 0.4);//+ rotateY(vec3(-0.15, 0.0, -0.15), 0.0);',
'  // r2 = vec3(2.0, 0.5, 0.3);//+ rotateY(vec3(-0.15, 0.0, -0.15), 0.0);',
'  // res = opU(res, vec2(sdCapsule(pos, r1, r2, .1), 31.9));',
'',
'  // r1 = vec3(1.95, 0.5, 0.35) ;',
'  // r2 = vec3(2.05, 0.5, 0.35) ;',
'  ',
'  // res = opU(res, vec2(sdCapsule(pos, r1, r2, .1), 31.9));',
'',
'',
'  r1 = vec3(2.2, 0.5, 0.35) ;',
'  r2 = vec3(2.2, 0.5, 0.35) ;',
'  res = opU(res, vec2(sdCapsule(pos, r1, r2, .05), 31.9));',
'',
'',
'  r1 = vec3(1.81, 0.5, 0.29) ;',
'  r2 = vec3(1.81, 0.5, 0.29) ;',
'  res = opU(res, vec2(sdCapsule(pos, r1, r2, .05), 31.9));',
'',
'',
'  r1 = vec3(1.81, 0.5, 0.38);',
'  r2 = vec3(1.81, 0.5, 0.38);',
'  res = opU(res, vec2(sdCapsule(pos, r1, r2, .05), 31.9));',
'',
'',
'  res = opU(res, vec2(sdTorus((pos - vec3(2.0, 0.5, 0.35)), vec2(0.12, 0.05)), 31.9));  ',
'  // r1 = vec3(2.0, 0.2, 0.2) ;',
'  // r2 = vec3(2.0, 0.5, -0.2) ;',
'  // res = opU(res, vec2(sdCapsule(pos, r1, r2, .1), 31.9));',
'',
'  // r1 = vec3(2.0, 0.2, 0.2) ;',
'  // r2 = vec3(2.0, 0.5, -0.2) ;',
'  // res = opU(res, vec2(sdCapsule(pos, r1, r2, .1), 31.9));',
'',
'  // res = opU(res, vec2(sdTriPrism(pos - vec3(-1.0, 0.25, -1.0), 0.1 * sin(iTime) + 0.25, 0.05), 43.5));',
'  // float h1 = 0.2;//0.2 + 0.06 * sin(iTime);',
'  // res = opU(res, vec2(sdCylinder(pos - vec3(2.0, .5, 0.5), vec2(0.2, h1+0.5)), 8.0));',
'  // vec3 posC = pos.xyz +vec3( -2, 0.0, 0.0);',
'  // r1 = rotateY(vec3(.20,1.0,.0) ,10);',
'  // res = opU(res, vec2(sdCylinder(posC - r1, vec2(0.5, h1)), 2.0));',
'  // res = opU(res, vec2(sdCone(pos - vec3(0.0, 0.50, -1.0), vec3(0.8, 0.5 + 0.1 * sin(iTime), 0.3)), 55.0));',
'  // res = opU(res, vec2(sdTorus82(pos - vec3(0.0, 0.25, 2.0), vec2(0.20, 0.05)), 50.0));',
'  // r1 = rotateY(pos - vec3(-1.0, 0.25, 2.0), iTime * 0.25);',
'  // res = opU(res, vec2(sdTorus88(r1, vec2(0.20, 0.05)), 43.0));',
'  // r1 = rotateY(pos - vec3(1.0, 0.30, 2.0), iTime * 0.25);',
'  // res = opU(res, vec2(sdCylinder6(r1, vec3(0.1, 0.05, 0.25)), 12.0));',
'  // r1 = rotateX(pos - vec3(-1.0, 0.25, 1.0), iTime * 0.5);',
'  // res = opU(res, vec2(sdHexPrism(r1, 0.25, 0.05), 17.0));',
'  // res = opU(res, vec2(sdBoxMinusSphere(pos - vec3(-2.0, 0.2, 1.0), 0.25), 13.0));',
'  // res = opU(res, vec2(sdRackWheel(pos), 51.0));',
'  // res = opU(res, vec2(sdTwistedTorus(pos - vec3(-2.0, 0.25, 2.0), 6.0 * sin(iTime)), 46.7));',
'  // res = opU(res, vec2(sdWaveSphere(pos - vec3(-2.0, 0.25, -1.0), 0.2, 10, sin(iTime) * 0.2), 880));',
'// res = opU( res, vec2( sdBallyBall   ( pos - vec3(-2.0, 0.25, -1.0)), 65.0 ) );',
'  return res;',
'}',
'',
'//----------------------------------------------------------------------',
'vec2 castRay(vec3 ro, vec3 rd) {',
'  float tmin = 1.0;',
'  float tmax = 20.0;',
'',
'  #if 0',
'  float tp1 = (0.0 - ro.y) / rd.y;',
'  if(tp1 > 0.0)',
'    tmax = min(tmax, tp1);',
'  float tp2 = (1.6 - ro.y) / rd.y;',
'  if(tp2 > 0.0) {',
'    if(ro.y > 1.6)',
'      tmin = max(tmin, tp2);',
'    else',
'      tmax = min(tmax, tp2);',
'  }',
'  #endif',
'',
'  float precis = 0.002;',
'  float t = tmin;',
'  float m = -1.0;',
'  for(int i = 0; i < 60; i++) {',
'    vec2 res = map(ro + (rd) * t);',
'    if(res.x < precis || t > tmax)',
'      break;',
'    t += res.x;',
'    m = res.y;',
'  }',
'',
'  if(t > tmax)',
'    m = -1.0;',
'  return vec2(t, m);',
'}',
'',
'//----------------------------------------------------------------------',
'float softshadow(vec3 ro, vec3 rd, float mint, float tmax) {',
'  float res = 1.0;',
'  float t = mint;',
'  for(int i = 0; i < 8; i += 1) {',
'    float h = map(ro + rd * t).x;',
'    res = min(res, 8.0 * h / t);',
'    t += clamp(h, 0.02, 0.10);',
'    if(h < 0.001 || t > tmax)',
'      break;',
'  }',
'  return clamp(res, 0.0, 1.0);',
'}',
'',
'//----------------------------------------------------------------------',
'vec3 calcNormal(vec3 pos) {',
'  vec3 eps = vec3(0.001, 0.0, 0.0);',
'  vec3 nor = vec3(map(pos + eps.xyy).x - map(pos - eps.xyy).x, map(pos + eps.yxy).x - map(pos - eps.yxy).x, map(pos + eps.yyx).x - map(pos - eps.yyx).x);',
'  return normalize(nor);',
'}',
'',
'//----------------------------------------------------------------------',
'float calcAO(vec3 pos, vec3 nor) {',
'  float occ = 0.0;',
'  float sca = 1.0;',
'  for(int i = 0; i < 5; i++) {',
'    float hr = 0.01 + 0.12 * float(i) / 4.0;',
'    vec3 aopos = nor * hr + pos;',
'    float dd = map(aopos).x;',
'    occ += -(dd - hr) * sca;',
'    sca *= 0.95;',
'  }',
'  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);',
'}',
'//---------------------------------------------------------',
// 'vec3 render(vec3 ro, vec3 rd) {',
// '  vec3 col = vec3(0.8, 0.9, 1.0);',
// '  vec2 res = castRay(ro, rd);',
// '  float t = res.x;',
// '  float m = res.y;',
// '  if(m > -0.5) {',
// '    vec3 pos = ro + t * rd;',
// '    vec3 nor = calcNormal(pos);',
// '    vec3 ref = reflect(rd, nor);',
// '',
// '    // material        ',
// '    col = 0.45 + 0.3 * sin(vec3(0.05, 0.08, 0.10) * (m - 1.0));',
// '',
// '    if(m < 1.5) {',
// '      float f = mod(floor(5.0 * pos.z) + floor(5.0 * pos.x), 2.0);',
// '      col = 0.4 + 0.1 * f * vec3(1.0);',
// '    }',
// '',
// '    // lighting        ',
// '    float occ = calcAO(pos, nor);',
// '    vec3 lig = normalize(vec3(-0.6, 0.7, -0.5));',
// '    float amb = clamp(0.8 + 0.8 * nor.y, 0.8, 1.0);',
// '    float dif = clamp(dot(nor, lig), 0.5,1.0);',
// '    float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0);',
// '    float dom = smoothstep(-50, -50, ref.y);',
// '    float fre = pow(clamp(0.5 + dot(nor, rd), 0.90, 1.0), 2.0);',
// '    float spe = pow(clamp(dot(ref, lig), 0.5, 1.0), 18.0);',
// '',
// '    dif *= softshadow(pos, lig, 0.02, 2.5);',
// '    dom *= softshadow(pos, ref, 0.2, 2.5);',
// '',
// '    vec3 brdf = vec3(0.0);',
// '    brdf += 1.20 * dif * vec3(1.00, 0.90, 0.60);',
// '    brdf += 1.20 * spe * vec3(1.00, 0.90, 0.60) * dif;',
// '    brdf += 0.30 * amb * vec3(0.50, 0.70, 1.00) * occ;',
// '    brdf += 0.40 * dom * vec3(0.50, 0.70, 1.00) * occ;',
// '    brdf += 0.30 * bac * vec3(0.25, 0.25, 0.25) * occ;',
// '    brdf += 0.40 * fre * vec3(1.00, 1.00, 1.00) * occ;',
// '    brdf += 0.02;',
// '    col = col * brdf;',
// '    col = mix(col, vec3(0.8, 0.9, 1.0), 1.0 - exp(-0.005 * t * t));',
// '  }',
// '  return vec3(clamp(col, 0.0, 1.0));',
// '}',
'',
'// Created by Stephane Cuillerdier - @Aiekick/2016',
'// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.',
'// Tuned via XShade (http://www.funparadigm.com/xshade/)',
'',
'// by shane',
'float Voronesque( in vec3 p )',
'{',
'    vec3 i  = floor(p+dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;',
'    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    ',
'    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;',
'    vec3 rnd = vec3(5.46,62.8,164.98); // my tuning',
'    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);',
'    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); ',
'    d = fract(sin(d)*1000.)*v*2.; ',
'    v.x = max(d.x, d.y), v.y = max(d.z, d.w); ',
'    return max(v.x, v.y);',
'}',
'',
'float df(vec3 p)',
'{',
'    float m = length(p) - 1.6;',
'	p.z += /*iTime **/ 0.82;',
'	return m + sqrt(Voronesque(p)*0.85);',
'}',
'',
'vec3 nor(vec3 p, float prec)',
'{',
'    vec2 e = vec2(-1.5, 1.5) * prec; ',
'    return normalize(e.yxx*df(p + e.yxx) + e.xxy*df(p + e.xxy) ',
'		+ e.xyx*df(p + e.xyx) + e.yyy*df(p + e.yyy) );',
'}',
'',
'vec3 shade(vec3 ro, vec3 rd, float d, vec3 v)',
'{',
'    vec3 p = ro + rd * d;',
'	vec3 np = normalize(p);			',
'	vec3 n = nor(p, 0.1);',
'	return (normalize(mix(vec3(max(0.,2.3-d)),np,0.28))',
'		* cross(vec3(5.0), reflect(rd, n)).brg * v.x',
'		+ pow(.15 + dot(n, np) * .66, 30.) * v.y) * v.z;',
'}',
'',
'const float n1 = 2.; //Power 1',
'const float n2 = 4.; //Power 2',
'const float iterations = 50.;',
'',
'vec2 Scale(vec2 p){',
'	return p;',
'}',
'',
'',
'float mandelbrot(vec2 c){',
'    vec2 z = vec2(0);',
'    ',
'    float t = sin(1.7/2.)*.5+.5;',
'    ',
'	for (int i=0;i<100;i++){',
'		//to (r,a)',
'		float rad = length(z);',
'		float phi = atan(z.y,z.x);',
'		',
'		//escaped?',
'		if (rad>5.) return float(i);',
'		',
'		//calculation1',
'		float rad1 = pow(rad,n1);',
'		float phi1 = phi*n1;',
'        ',
'        //calculation2',
'		float rad2 = pow(rad,n2);',
'		float phi2 = phi*n2;',
'		',
'		//to (x,y)',
'		z = vec2(',
'			cos(phi1)*rad1,',
'			sin(phi1)*rad1',
'		)*t+',
'        vec2(',
'			cos(phi2)*rad2,',
'			sin(phi2)*rad2',
'		)*(1.-t)',
'        +c;',
'	}	',
'	return iterations;',
'}',
'',
// 'mat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}',
// 'const mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.93;',
// 'float mag2(vec2 p){return dot(p,p);}',
// 'float linstep(in float mn, in float mx, in float x){ return clamp((x - mn)/(mx - mn), 0., 1.); }',
// 'float prm1 = 0.;',
// 'vec2 bsMo = vec2(0);',
// '',
// 'vec2 disp(float t){ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; }',
// '',
// 'vec2 map2(vec3 p)',
// '{',
// '    vec3 p2 = p;',
// '    p2.xy -= disp(p.z).xy;',
// '    p.xy *= rot(sin(p.z+0.2)*(0.1 + prm1*0.05) + 0.3*0.09);',
// '    float cl = mag2(p2.xy);',
// '    float d = 0.;',
// '    p *= .61;',
// '    float z = 1.;',
// '    float trk = 1.;',
// '    float dspAmp = 0.1 + prm1*0.2;',
// '    for(int i = 0; i < 5; i++)',
// '    {',
// '		p += sin(p.zxy*0.75*trk + 0.1*trk*.8)*dspAmp;',
// '        d -= abs(dot(cos(p), sin(p.yzx))*z);',
// '        z *= 0.57;',
// '        trk *= 1.4;',
// '        p = p*m3;',
// '    }',
// '    d = abs(d + prm1*3.)+ prm1*.3 - 2.5 + bsMo.y;',
// '    return vec2(d + cl*.2 + 0.25, cl);',
// '}',
// '',
// 'vec4 render( in vec3 ro, in vec3 rd, float time )',
// '{',
// 'vec4 rez = vec4(0);',
// 'const float ldst = 8.;',
// 'vec3 lpos = vec3(disp(time + ldst)*0.5, time + ldst);',
// 'float t = 1.5;',
// 'float fogT = 0.;',
// // ' ro *=',
// 'for(int i=0; i<50; i++)',
// '{',
// '    if(rez.a > 0.59)break;',
// '',
// '    vec3 pos = ro + t*rd-0.5;',
// '    vec2 mpv = map2(pos);',
// '    float den = clamp(mpv.x-0.03,0.02,1.022)*1.12;',
// '    float dn = clamp((mpv.x + 2.),0.,3.);',
// '    ',
// '    vec4 col = vec4(0);',
// '    if (mpv.x > 0.96)',
// '    {',
// '    ',
// '        col = vec4(sin(vec3(1.,1.0,1.0) + mpv.y*1.51 +sin(0.94)*0.5 + 1.28)*0.5 + 0.5,0.98);',
// '        col *= den*den*den;',
// '        col.rgb *= linstep(4.,-2.5, mpv.x)*2.3;',
// '        float dif =  clamp((den - map(pos+.8).x)/9., 0.001, 1. );',
// '        dif += clamp((den - map2(pos+.35).x)/2.5, 0.001, 1. );',
// '        col.xyz *= den*(vec3(0.005,.045,.075) + 1.5*vec3(0.033,0.07,0.03)*dif);',
// '    }',
// '    ',
// '    float fogC = exp(t*0.2 - 2.2);',
// '    col.rgba += vec4(0.06,0.11,0.11, 0.1)*clamp(fogC-fogT, 0., 1.);',
// '    fogT = fogC;',
// '    rez = rez + col*(1. - rez.a);',
// '    t += clamp(0.5 - dn*dn*.05, 0.09, 0.3);',
// '}',
// 'return clamp(rez, 0.0, 1.0);',
// '',
// '}',
// '',
// 'float getsat(vec3 c)',
// '{',
// '    float mi = min(min(c.x, c.y), c.z);',
// '    float ma = max(max(c.x, c.y), c.z);',
// '    return (ma - mi)/(ma+ 1e-7);',
// '}',
// '',
// '//from my "Will it blend" shader (https://www.shadertoy.com/view/lsdGzN)',
// 'vec3 iLerp(in vec3 a, in vec3 b, in float x)',
// '{',
// '    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,0.);',
// '    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));',
// '    vec3 dir = normalize(vec3(2.*ic.x - ic.y - ic.z, 2.*ic.y - ic.x - ic.z, 2.*ic.z - ic.y - ic.x));',
// '    float lgt = dot(vec3(1.0), ic);',
// '    float ff = dot(dir, normalize(ic));',
// '    ic += 1.5*dir*sd*ff*lgt;',
// '    return clamp(ic,0.,1.);',
// '}',
'void mainImage( out vec4 f, vec2 g )',
'{',
'    //f.xy = iResolution.xy/iResolution.y;',
'    g = ((-g+2.0)*2.0)/iResolution.y;///iResolution.y;//(g-2.0*f.xy)/f.y;',
'    ',
// '    iTime =1.0;',
// '    float t = 0.0 * 0.5;',
'    float tt = clamp(abs(cameraPosition.y+cameraPosition.x),0.1,100.0) * 0.20;',
'    ',
'    vec3 cu = vec3(0.0,1.0,0.0);',
// '    vec3 ro = vec3(0.5 * 100.,100.,0.5 * 200.);//vec3(/*cos(t) * */20.,10.,/*sin(t) **/ 10.);',
'    vec3 ro = vec3((cos(tt)) *1.,10.,(sin(tt)) * 10.);',
// '    vec3 ro = vec3((5.0+10.0),5.,5.0+ 10.);',
'    vec3 co = vec3(0.,0.,0.);',
'	',
'	float fov = 1.;',
'	vec3 axisZ = normalize(co - ro);',
'	vec3 axisX = normalize(cross(cu, axisZ));',
'	vec3 axisY = normalize(cross(axisZ, axisX));',
'	vec3 rd = normalize(axisZ + fov * g.x * axisX + fov * g.y * axisY);',
'    ',
'    vec3 p=ro, np, n, col, colss;',
'    ',
'    //f = texture(iChannel0, rd);',
'    ',
'    float d=0.01,s=2.0;',
'	',
'	for(int i=0;i<150;i++)',
'		if(s>0.1 && d<.02)',
'			d+=s=df(ro+rd*d);',
'	',
// '    vec3 color ;',
'    float ff = 0.350;',
'	// surface',
'    if (d<250.)',
'    {',
// '       col = vec3(0.2,0.5,0.85);',
'		// surface color',
'        col = shade(ro, rd, d, vec3(0.9,0.0,1));',
// '        col = shade(ro, rd, d, vec3(.9,0.0,1));',
'        ',
'        // sub surface',
'        ro = ro+rd*d;',
'        d = 1.;',
'',
'        // sub surface color',
'        colss = shade(ro, rd, d, vec3(1,1,3));',
'        float ratio = 0.45;',
'		colss = clamp(colss, 0., 1./(1.-ratio));',
'        ',
'        ',
'		f.rgb = mix(col, colss, ratio);',
'       ff= clamp(dot(cameraPosition-rd,cameraPosition-d), 0.3, 0.5);',
'	}',
// '   else{',
// '       color = vec3(0.9,0.0,0.);',
// '   }',

'    vec3 color2 = vec3(1.,1.,1.0);',
'    vec3 color = vec3(0.2,0.5,0.95);',
// '    f.rgb = mix(color, f.rgb, 0.25);',
'    f.rgb = mix(color, f.rgb, alpha1);',
// '    f.rgb = mix(color2, f.rgb, 0.33);',
'    f.rgb = mix(color2, f.rgb, alpha2);',
// '    f.rgb = mix(color2, f.rgb, 0.1);',
    // 'vec2 scaledp = g.xy*0.5-0.2;//Scale(g.xy);',
	// 'vec3 color5 = vec3(mandelbrot(scaledp)/iterations);',
// '    f.rgb = mix(color5, f.rgb, 0.9);',
'}',
'',
'void mainImage2( out vec4 fragColor, in vec2 fragCoord )',
'{	',
'vec2 q = fragCoord.xy*0.00002;',
'vec2 p = (gl_FragCoord.xy)*0.002;',
'bsMo = (vec2(0.51,0.52) - .0*iResolution.xy);',
'',
'float time = iTime*3.;',
'vec3 ro = vec3(0.0,-0.0,time-60.0);',
'',
// 'ro += vec3(sin(0.1)*0.5,sin(0.5*1.)*0.,0);',
'ro -= vec3(-1.0,-1.0,-6.0);',
'    ',
'float dspAmp = .125;',
// 'ro.xy -= disp(ro.z)*dspAmp;',
'float tgtDst = .825;',
'',
'vec3 target = normalize(ro - vec3(disp(time + tgtDst)*dspAmp, time + tgtDst));',
// 'ro.x -= bsMo.x*2.;',
'vec3 rightdir = normalize(cross(target, vec3(0.5,0.5,0)));',
'vec3 updir = normalize(cross(rightdir, target));',
'rightdir = normalize(cross(updir, target));',
'vec3 rd=normalize((p.x*rightdir + p.y*updir)*1. - target);',
'rd.xy *= rot(-disp(time + .5).x*0.8 + bsMo.x);',
'prm1 = smoothstep(0., 0.8,sin(dot(bsMo,bsMo)*0.3));',
'vec4 scn = render(ro, rd, time);',
'    ',
'vec3 col = scn.rgb;',
'col = iLerp(col.bgr, col.rgb, clamp(1.-prm1,0.1,1.));',
'',
'col = pow(col, vec3(.50,.50,.50))*vec3(1.2,1.2,1.20);',
'vec3 colo = vec3(1.0);',
// 'colo *= pow( .820*q.x*q.y*(1.0-q.x)*(1.0-q.y), 1.5212)*5.952+0.4512193; //Vign',
'col = colo + col;',
// 'col = clamp(col,0.0,0.8);',
// 'col += vec3(0.2,0.2,0.2);',
'fragColor = vec4( col, 1.0 );',
'}',
// '',
// '//---------------------------------------------------------',
// 'void main() {',
// '  // pixel color',
// '  //vec3 col = render(ro, rd);',
// '  vec4 col,col2;',
// '  vec3 color;',
// '  mainImage( col, gl_FragCoord.xy );',
// '  mainImage2( col2, gl_FragCoord.xy );',
// '  color = clamp(col2.xyz, 0.0,1.0);',
// // '  color = mix(col2.xyz, col.xyz,.50);',
// // '  color *= col.xyz;',

// // '  color = pow(color, vec3(.4545));',
// '  gl_FragColor = vec4(color, 1.0);',
// '}',
/************************* */


// '#ifdef GL_ES',
// 'precision mediump float;',
// '#endif',
// '',
// 'uniform vec2 Resolution;',
// 'uniform vec2 iMouse;',
// 'uniform float iTime;',
// 'uniform vec3 eye;',
// 'float scale= 0.002;',
// '',
'vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }',
'vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }',
'vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }',
'',
'float random (in vec2 st) {',
'    return fract(sin(dot(st.xy,',
'                         vec2(12.9898,78.233)))',
'                * 43758.5453123);',
'}',
// '',
'float snoise(vec2 v) {',
'    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0',
'                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)',
'                        -0.577350269189626,  // -1.0 + 2.0 * C.x',
'                        0.024390243902439); // 1.0 / 41.0',
'    vec2 i  = floor(v + dot(v, C.yy) );',
'    vec2 x0 = v -   i + dot(i, C.xx);',
'    vec2 i1;',
'    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);',
'    vec4 x12 = x0.xyxy + C.xxzz;',
'    x12.xy -= i1;',
'    i = mod289(i); // Avoid truncation effects in permutation',
'    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))',
'        + i.x + vec3(0.0, i1.x, 1.0 ));',
'',
'    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);',
'    m = m*m ;',
'    m = m*m ;',
'    vec3 x = 2.0 * fract(p * C.www) - 1.0;',
'    vec3 h = abs(x) - 0.5;',
'    vec3 ox = floor(x + 0.5);',
'    vec3 a0 = x - ox;',
'    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );',
'    vec3 g;',
'    g.x  = a0.x  * x0.x  + h.x  * x0.y;',
'    g.yz = a0.yz * x12.xz + h.yz * x12.yw;',
'    return 130.0 * dot(m, g);',
'}',
// '',
'float cloud(vec2 st, float w, float b) {',
'    float n = 0.0;',
'    for (float i = 1.0; i < 8.0; i ++) {',
'        float m = pow(3.784, i);',
'        n += snoise(st * m) * (1.0 / m);',
'    }',
'    return n * w + b;',
'}',
// '',
'void mainImage5(out vec4 fragColor, in vec2 fragCoord) {',
'    vec2 st = (clamp(dot(eye,eye),0.,0.002)+0.0001)*gl_FragCoord.xy  ;',
// '    st.x *= Resolution.x / Resolution.y;',
'    float v = cloud(st, 0.252, 0.384);',
'    float v2 = cloud(st,0.660, 0.272);',
'    vec3 color=(-v - (-1.136))*vec3(.835,.817,.809);',
'    vec3 color2=(1.064-(0.500)*(v2+-0.056))*vec3(.25,0.075,0.084);',
'    ',
'    color = mix(color, color2, -0.876);',
'    color *= mix(color, color2, -0.044);',
'    ',
'    fragColor = vec4(color, 1.0);',
'}',
/******************************* */

// 'uniform vec2      iResolution;', // viewport resolution (in pixels)
// 'uniform vec2 iMouse;',
// // 'uniform vec2 mouse;',
// 'uniform float iTime;',
'',

'',
'mat4 rotationMatrix(vec3 axis, float angle)',
'{',
'    axis = normalize(axis);',
'    float s = sin(angle);',
'    float c = cos(angle);',
'    float oc = 1.0 - c;',
'    ',
'    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,',
'                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,',
'                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,',
'                0.0,                                0.0,                                0.0,                                1.0);',
'}',
'mat4 transMatrix(vec3 axis)',
'{',
'    axis = normalize(axis);',
'    ',
'    return mat4(1.0,  0.0,  0.0,  axis.x,',
'                0.0,  1.0,  0.0,  axis.y,',
'                0.0,  0.0,  1.0,  axis.z,',
'                0.0,  0.0,  0.0,  1.0    );',
'}',
// 'uniform vec3 eye;',
'void mainImage3( out vec4 fragColor, in vec2 fragCoord )',
'{	',
'	vec2 q = fragCoord.xy/iResolution.xy;',
'   vec2 p = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;',
'    p = (rotationMatrix(vec3(0.0, 1.0, 0.0), dot(p.xyx,eye.xyz)) * vec4(p.x,p.y,1.0,1.0)).xy;',
'    bsMo = (vec2(0.1,0.2) - 0.5*iResolution.xy)/iResolution.y;',
'    ',
'    float time = 0.0*3.;',
'    vec3 ro = vec3(0,0,time);',
'    ',
'    ro += vec3(sin(0.1)*0.5,sin(0.5*1.)*0.,0);',
'    ro = vec3(1.0,-1.0,1.0);',
'        ',
'    float dspAmp = .25;',
'    ro.xy -= disp(ro.z)*dspAmp;',
'    float tgtDst = .25;',
'    ',
'    vec3 target = normalize(ro - vec3(disp(time + tgtDst)*dspAmp, time + tgtDst));',
'    ro.x -= bsMo.x*2.;',
'    vec3 rightdir = normalize(cross(target, vec3(0.5,0.5,0)));',
'    vec3 updir = normalize(cross(rightdir, target));',
'    rightdir = normalize(cross(updir, target));',
'	vec3 rd=normalize((p.x*rightdir + p.y*updir)*1. - target);',
'    rd.xy *= rot(-disp(time + .5).x*0.8 + bsMo.x);',
'    prm1 = smoothstep(0., 0.8,sin(dot(bsMo,bsMo)*0.3));',
'	vec4 scn = render(ro, rd, time);',
'		',
'    vec3 col = scn.rgb;',
'    col = iLerp(col.bgr, col.rgb, clamp(1.-prm1,0.1,1.));',
'    ',
'    col = pow(col, vec3(.50,.50,.50))*vec3(1.2,1.2,1.20);',
'    vec3 colo = vec3(1.0);',
'    colo *= pow( .820*q.x*q.y*(1.0-q.x)*(1.0-q.y), 1.5212)*5.952+0.4512193; //Vign',
'    col = colo + col;',
'    //col = clamp(col,0.0,0.8);',
'    //col += vec3(0.2,0.2,0.2);',
'	fragColor = vec4( col, 1.0 );',
'}',

'void main() {',
'  // pixel color',
'  //vec3 col = render(ro, rd);',
'  vec4 col,col2;',
'  vec3 color;',
// '  vec3 d = (rotationMatrix(vec3(0.0, 1.0, 0.0), 2.0*3.14) * vec4(gl_FragCoord.xyz,1.0)).xyz;',
'  mainImage2( col, gl_FragCoord.xy );',
'  mainImage( col2, gl_FragCoord.xy );',
'  color = clamp(col.xyz, 0.0,0.95);',
'  color = mix(col2.xyz, color.xyz,.160);',
// '  color = col2.xyz;',

'  color = pow(color, vec3(1.245));',
' vec3 normal = normalize( vNormal);',
' vec3 lightdir = normalize(vec4(0.0,0.0,-10000000000.0,1.0)-gl_FragCoord).xyz;',
' float dif = max(dot(normal, lightdir), 0.0);',
	// specular lighting
	'float specularLight = 0.50f;',
	'vec3 viewDirection = normalize(eye - gl_FragCoord.xyz);',
	'vec3 reflectionDirection = reflect(lightdir, normal);',
	'float specAmount = pow(max(dot(viewDirection, reflectionDirection), 0.0f), 8.0);',
'   float specular = specAmount * specularLight;',
'if(dot(normal, lightdir)>0.0)',
'{',
    ' color = color * vec3(1.0) * (dif+0.2+specular);',
'}',
'else',
' color = color * vec3(1.0) * (0.0+0.2+0.0);',
'  mainImage5( col, gl_FragCoord.xy );',
'  color *=mix(col.xyz, color.xyz,.560);',
' color = clamp(color, vec3(0.0),vec3(1.0));',
// ' color *= pow( 0.220, 1.5212)*5.952+0.4512193; //Vign',

// 'if(color != vec3(1.0) && color.b > vec3(1.0).b  && color.r > vec3(1.0).r && color.g > vec3(0.50).g)',
// '{',
//     ' color = color * vec3(0.50,0.50,8.0) * (dif+0.01+specular);',
// '}',
// 'if(color != vec3(1.0) && color.b > vec3(8.0).b && color.b < vec3(9.0).b  && color.r > vec3(1.0).r && color.g > vec3(0.80).g)',
// '{',
//     ' color = color * vec3(0.50,0.0,.0) * (dif+0.21+specular);',
// '}',
'  gl_FragColor = vec4(color, 1.0);',
'}',

    ]).join('\n'),
    uniforms : {
        "iResolution" : {value : new Vector3()},
        "iTime" : {value : 0.0,type: "f"},
        "fov" : {value : 75},
        "iMouse" : {value : new Vector2()},
        "eye" : {value : new Vector3()},
        "center" : {value : new Vector3()},
        "alpha1" : {value : 0.0,type: "f"},
        "alpha2" : {value : 0.0,type: "f"},
        "alpha3" :{value : 0.0,type: "f"},
        "alpha4" : {value : 0.0,type: "f"},
        "alpha5" : {value : 0.0,type: "f"},
        // "mouse" : {value: new Vector2()},
    }
}

export var M_opal = new ShaderMaterial({
    vertexShader: opalShader.vertexShader,
    fragmentShader:opalShader.fragmentShader,
    uniforms:opalShader.uniforms,
});

