import { ShaderMaterial, Vector2, Vector3, Vector4 } from "./three.module.js";



export var opalShader = {
    vertexShader:([
        'varying vec3 vNormal;',
        'varying vec2 vUv;',
        'uniform vec3 eye;',
        'mat4 rotationMatrix(vec3 axis, float angle)',
        '{',
        '    axis = normalize(axis);',
        '    float s = sin(angle);',
        '    float c = cos(angle);',
        '    float oc = 1.0 - c;',
        '    ',
        '    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,',
        '                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,',
        '                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,',
        '                0.0,                                0.0,                                0.0,                                1.0);',
        '}',
        'void main()',
        '{',
        ' vNormal = normal;',
        ' vUv = uv;',

        '    vec3 position_t = (rotationMatrix(vec3(1.0, 0.0, 0.0), -3.14/2.0) * vec4(position,1.0)).xyz;',
         //'position = rotationMatrix(1.0,0.0,0.0,3.14/2.0) * vec4(position,1.0); ',
        ' gl_Position = projectionMatrix * modelViewMatrix * vec4( position_t, 1.0 );',
        '}',
    ]).join('\n'),
    fragmentShader : ([
        'varying vec3 vNormal;',
        'varying vec2 vUv;',
        //this is based on https://www.shadertoy.com/view/4tcGDr
        'uniform vec3      iResolution;',           // viewport resolution (in pixels)
        'uniform float     iTime;',
        'uniform vec4      iMouse;',               // shader playback time (in seconds)
        'uniform vec3      eye;',               // Camera position
        'uniform vec3      center;',               // Camera target
        'uniform float     fov;',               // Camera target
        'uniform vec2     mouse;',               // Camera target
        'uniform float     alpha1;',               // Camera target
        'uniform float     alpha2;',               // Camera target
        'uniform float     alpha3;',               // Camera target
        'uniform float     alpha4;',               // Camera target
        'uniform float     alpha5;',               // Camera target
        'uniform float     alpha6;',               // Camera target
        'uniform float     w1;',               // cloud
        'uniform float     w2;',               // cloud
        'uniform float     b1;',               // cloud
        'uniform float     b2;',               // cloud
        'uniform vec3     color_cloud;',       // cloud
        'uniform float     alpha_cloud;',      // cloud
'',
'#define ROTATE false   ',
'#define flag true',
'',

'mat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}',
'const mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.93;',
'float mag2(vec2 p){return dot(p,p);}',
'float linstep(in float mn, in float mx, in float x){ return clamp((x - mn)/(mx - mn), 0., 1.); }',
'float prm1 = 0.;',
'vec2 bsMo = vec2(0);',
'',
'vec2 disp(float t){ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; }',
'',
'vec2 map(vec3 p)',
'{',
'    vec3 p2 = p;',
'    p2.xy -= disp(p.x).yx;',
'    p.xy *= rot(sin(p.x+0.2)*(0.1 + prm1*0.05) + 0.93*0.9);',
'    float cl = mag2(p2.xy);',
'    float d = 0.;',
'    p *= .91;',
'    float z = 1.;',
'    float trk = 1.;',
'    float dspAmp = .51 + prm1*0.82;',
'    for(int i = 0; i < 5; i++)',
'    {',
'		p += sin(p.zxy*0.275*trk + 0.1*trk*.8)*dspAmp;',
'        d -= abs(dot(cos(p), sin(p.yzx))*z);',
'        z *= 0.57;',
'        trk *= 1.24;',
'        p = p*m3;',
'    }',
'    d = abs(d + prm1*3.)+ prm1*.3 - 2.5 + bsMo.y;',
'    return vec2(d + cl*.2 + 0.25, cl);',
'}',
'',
'vec4 render( in vec3 ro, in vec3 rd, float time )',
'{',
'	vec4 rez = vec4(0);',
'    const float ldst = 8.;',
'	vec3 lpos = vec3(disp(time + ldst)*0.5, time + ldst);',
'	float t = 1.5;',
'	float fogT = 0.;',
'	for(int i=0; i<50; i++)',
'	{',
'		if(rez.a > 0.49)break;',
'',
'		vec3 pos = ro + t*rd;',
'        vec2 mpv = map(pos);',
'		float den = clamp(mpv.x-0.3,0.,1.)*1.12;',
'		float dn = clamp((mpv.x + 2.),0.,3.);',
'        ',
'		vec4 col = vec4(0);',
'        if (mpv.x > 0.6)',
'        {',
'        ',
'            col = vec4(sin(vec3(1.,1.0,1.0) + mpv.y*1.51 +sin(pos.z*0.94)*0.5 + 1.28)*0.5 + 0.5,0.98);',
'            col *= den*den*den;',
'			col.rgb *= linstep(4.,-2.5, mpv.x)*2.3;',
'            float dif =  clamp((den - map(pos+.8).x)/9., 0.001, 1. );',
'            dif += clamp((den - map(pos+.35).x)/2.5, 0.001, 1. );',
'            col.xyz *= den*(vec3(0.005,.045,.075) + 1.5*vec3(0.033,0.07,0.03)*dif);',
'        }',
'		',
'		float fogC = exp(t*0.2 - 2.2);',
'		col.rgba += vec4(0.06,0.11,0.11, 0.1)*clamp(fogC-fogT, 0., 1.);',
'		fogT = fogC;',
'		rez = rez + col*(1. - rez.a);',
'		t += clamp(0.5 - dn*dn*.05, 0.09, 0.3);',
'	}',
'	return clamp(rez, 0.0, 1.0);',
'}',
'',
'float getsat(vec3 c)',
'{',
'    float mi = min(min(c.x, c.y), c.z);',
'    float ma = max(max(c.x, c.y), c.z);',
'    return (ma - mi)/(ma+ 1e-7);',
'}',
'',
'//from my "Will it blend" shader (https://www.shadertoy.com/view/lsdGzN)',
'vec3 iLerp(in vec3 a, in vec3 b, in float x)',
'{',
'    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,0.);',
'    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));',
'    vec3 dir = normalize(vec3(2.*ic.x - ic.y - ic.z, 2.*ic.y - ic.x - ic.z, 2.*ic.z - ic.y - ic.x));',
'    float lgt = dot(vec3(1.0), ic);',
'    float ff = dot(dir, normalize(ic));',
'    ic += 1.5*dir*sd*ff*lgt;',
'    return clamp(ic,0.,1.);',
'}',

'',
'// Created by Stephane Cuillerdier - @Aiekick/2016',
'// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.',
'// Tuned via XShade (http://www.funparadigm.com/xshade/)',
'',
'// by shane',
'float Voronesque( in vec3 p )',
'{',
'    vec3 i  = floor(p+dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;',
'    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    ',
'    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;',
'    vec3 rnd = vec3(5.46,62.8,164.98); // my tuning',
'    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);',
'    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); ',
'    d = fract(sin(d)*1000.)*v*2.; ',
'    v.x = max(d.x, d.y), v.y = max(d.z, d.w); ',
'    return max(v.x, v.y);',
'}',
'',
'float df(vec3 p)',
'{',
'    float m = length(p) - 1.6;',
'	p.z += /*iTime **/ 0.82;',
'	return m + sqrt(Voronesque(p)*0.85);',
'}',
'',
'vec3 nor(vec3 p, float prec)',
'{',
'    vec2 e = vec2(-1.5, 1.5) * prec; ',
'    return normalize(e.yxx*df(p + e.yxx) + e.xxy*df(p + e.xxy) ',
'		+ e.xyx*df(p + e.xyx) + e.yyy*df(p + e.yyy) );',
'}',
'',
'vec3 shade(vec3 ro, vec3 rd, float d, vec3 v)',
'{',
'    vec3 p = ro + rd * d;',
'	vec3 np = normalize(p);			',
'	vec3 n = nor(p, 0.1);',
'	return (normalize(mix(vec3(max(0.,2.3-d)),np,0.28))',
'		* cross(vec3(5.0), reflect(rd, n)).brg * v.x',
'		+ pow(.15 + dot(n, np) * .66, 30.) * v.y) * v.z;',
'}',
'',

'void mainImage( out vec4 f, vec2 g )',
'{',
'    //f.xy = iResolution.xy/iResolution.y;',
'    g = ((-g+2.0)*2.0)/iResolution.y;///iResolution.y;//(g-2.0*f.xy)/f.y;',
'    ',
// '    iTime =1.0;',
// '    float t = 0.0 * 0.5;',
'    float tt = clamp(abs(cameraPosition.y+cameraPosition.x),0.1,100.0) * 0.20;',
'    ',
'    vec3 cu = vec3(0.0,1.0,0.0);',
// '    vec3 ro = vec3(0.5 * 100.,100.,0.5 * 200.);//vec3(/*cos(t) * */20.,10.,/*sin(t) **/ 10.);',
'    vec3 ro = vec3((cos(tt)) *1.,10.,(sin(tt)) * 10.);',
// '    vec3 ro = vec3((5.0+10.0),5.,5.0+ 10.);',
'    vec3 co = vec3(0.,0.,0.);',
'	',
'	float fov = 1.;',
'	vec3 axisZ = normalize(co - ro);',
'	vec3 axisX = normalize(cross(cu, axisZ));',
'	vec3 axisY = normalize(cross(axisZ, axisX));',
'	vec3 rd = normalize(axisZ + fov * g.x * axisX + fov * g.y * axisY);',
'    ',
'    vec3 p=ro, np, n, col, colss;',
'    ',
'    //f = texture(iChannel0, rd);',
'    ',
'    float d=0.01,s=2.0;',
'	',
'	for(int i=0;i<150;i++)',
'		if(s>0.1 && d<.02)',
'			d+=s=df(ro+rd*d);',
'	',
// '    vec3 color ;',
'    float ff = 0.350;',
'	// surface',
'    if (d<250.)',
'    {',
// '       col = vec3(0.2,0.5,0.85);',
'		// surface color',
'        col = shade(ro, rd, d, vec3(0.9,0.0,1));',
// '        col = shade(ro, rd, d, vec3(.9,0.0,1));',
'        ',
'        // sub surface',
'        ro = ro+rd*d;',
'        d = 1.;',
'',
'        // sub surface color',
'        colss = shade(ro, rd, d, vec3(1,1,3));',
'        float ratio = 0.45;',
'		colss = clamp(colss, 0., 1./(1.-ratio));',
'        ',
'        ',
'		f.rgb = mix(col, colss, ratio);',
'       ff= clamp(dot(cameraPosition-rd,cameraPosition-d), 0.3, 0.5);',
'	}',
// '   else{',
// '       color = vec3(0.9,0.0,0.);',
// '   }',

'    vec3 color2 = vec3(1.,1.,1.0);',
'    vec3 color = vec3(0.2,0.5,0.95);',
// '    f.rgb = mix(color, f.rgb, 0.25);',
'    f.rgb = mix(color, f.rgb, alpha1);',
// '    f.rgb = mix(color2, f.rgb, 0.33);',
'    f.rgb = mix(color2, f.rgb, alpha2);',
// '    f.rgb = mix(color2, f.rgb, 0.1);',
    // 'vec2 scaledp = g.xy*0.5-0.2;//Scale(g.xy);',
	// 'vec3 color5 = vec3(mandelbrot(scaledp)/iterations);',
// '    f.rgb = mix(color5, f.rgb, 0.9);',
'}',
'',
'void mainImage2( out vec4 fragColor, in vec2 fragCoord )',
'{	',
'vec2 q = fragCoord.xy*0.00002;',
'vec2 p = (gl_FragCoord.xy)*0.002;',
'bsMo = (vec2(0.51,0.52) - .0*iResolution.xy);',
'',
'float time = iTime*3.;',
'vec3 ro = vec3(0.0,-0.0,time-60.0);',
'',
// 'ro += vec3(sin(0.1)*0.5,sin(0.5*1.)*0.,0);',
'ro -= vec3(-1.0,-1.0,-6.0);',
'    ',
'float dspAmp = .125;',
// 'ro.xy -= disp(ro.z)*dspAmp;',
'float tgtDst = .825;',
'',
'vec3 target = normalize(ro - vec3(disp(time + tgtDst)*dspAmp, time + tgtDst));',
// 'ro.x -= bsMo.x*2.;',
'vec3 rightdir = normalize(cross(target, vec3(0.5,0.5,0)));',
'vec3 updir = normalize(cross(rightdir, target));',
'rightdir = normalize(cross(updir, target));',
'vec3 rd=normalize((p.x*rightdir + p.y*updir)*1. - target);',
'rd.xy *= rot(-disp(time + .5).x*0.8 + bsMo.x);',
'prm1 = smoothstep(0., 0.8,sin(dot(bsMo,bsMo)*0.3));',
'vec4 scn = render(ro, rd, time);',
'    ',
'vec3 col = scn.rgb;',
'col = iLerp(col.bgr, col.rgb, clamp(1.-prm1,0.1,1.));',
'',
'col = pow(col, vec3(.50,.50,.50))*vec3(1.2,1.2,1.20);',
'vec3 colo = vec3(1.0);',
// 'colo *= pow( .820*q.x*q.y*(1.0-q.x)*(1.0-q.y), 1.5212)*5.952+0.4512193; //Vign',
'col = colo + col;',
// 'col = clamp(col,0.0,0.8);',
// 'col += vec3(0.2,0.2,0.2);',
'fragColor = vec4( col, 1.0 );',
'}',
// '',
// '//---------------------------------------------------------',
// 'void main() {',
// '  // pixel color',
// '  //vec3 col = render(ro, rd);',
// '  vec4 col,col2;',
// '  vec3 color;',
// '  mainImage( col, gl_FragCoord.xy );',
// '  mainImage2( col2, gl_FragCoord.xy );',
// '  color = clamp(col2.xyz, 0.0,1.0);',
// // '  color = mix(col2.xyz, col.xyz,.50);',
// // '  color *= col.xyz;',

// // '  color = pow(color, vec3(.4545));',
// '  gl_FragColor = vec4(color, 1.0);',
// '}',
/************************* */


// '#ifdef GL_ES',
// 'precision mediump float;',
// '#endif',
// '',
// 'uniform vec2 Resolution;',
// 'uniform vec2 iMouse;',
// 'uniform float iTime;',
// 'uniform vec3 eye;',
// 'float scale= 0.002;',
// '',
'vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }',
'vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }',
'vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }',
'',
'float random (in vec2 st) {',
'    return fract(sin(dot(st.xy,',
'                         vec2(12.9898,78.233)))',
'                * 43758.5453123);',
'}',
// '',
'float snoise(vec2 v) {',
'    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0',
'                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)',
'                        -0.577350269189626,  // -1.0 + 2.0 * C.x',
'                        0.024390243902439); // 1.0 / 41.0',
'    vec2 i  = floor(v + dot(v, C.yy) );',
'    vec2 x0 = v -   i + dot(i, C.xx);',
'    vec2 i1;',
'    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);',
'    vec4 x12 = x0.xyxy + C.xxzz;',
'    x12.xy -= i1;',
'    i = mod289(i); // Avoid truncation effects in permutation',
'    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))',
'        + i.x + vec3(0.0, i1.x, 1.0 ));',
'',
'    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);',
'    m = m*m ;',
'    m = m*m ;',
'    vec3 x = 2.0 * fract(p * C.www) - 1.0;',
'    vec3 h = abs(x) - 0.5;',
'    vec3 ox = floor(x + 0.5);',
'    vec3 a0 = x - ox;',
'    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );',
'    vec3 g;',
'    g.x  = a0.x  * x0.x  + h.x  * x0.y;',
'    g.yz = a0.yz * x12.xz + h.yz * x12.yw;',
'    return 130.0 * dot(m, g);',
'}',
// '',
'float cloud(vec2 st, float w, float b) {',
'    float n = 0.0;',
'    for (float i = 1.0; i < 8.0; i ++) {',
'        float m = pow(3.784, i);',
'        n += snoise(st * m) * (1.0 / m);',
'    }',
'    return n * w + b;',
'}',
// '',
'void mainImage5(out vec4 fragColor, in vec2 fragCoord) {',
'    vec2 st = (clamp(dot(eye,eye),0.,0.002)+0.0001)*gl_FragCoord.xy  ;',
// '    st.x *= Resolution.x / Resolution.y;',
'    float v = cloud(st, 0.252, 0.384);',
'    float v2 = cloud(st,0.660, 0.272);',
'    vec3 color=(-v - (-1.136))*vec3(.835,.817,.809);',
// '    vec3 color=(-v - (-1.136))*vec3(.835,.817,.809);',
'    vec3 color2=(1.064-(0.500)*(v2+-0.056))*vec3(.25,0.075,0.084);',
'    ',
// '    color = mix(color, color2, -0.876);',
// '    color *= mix(color, color2, -0.044);',
'    color = mix(color, color2, -alpha3);',
'    color *= mix(color, color2, -alpha4);',
'    ',
'    fragColor = vec4(color, 1.0);',
'}',
/******************************* */

// 'uniform vec2      iResolution;', // viewport resolution (in pixels)
// 'uniform vec2 iMouse;',
// // 'uniform vec2 mouse;',
// 'uniform float iTime;',
'',

'',
'mat4 rotationMatrix(vec3 axis, float angle)',
'{',
'    axis = normalize(axis);',
'    float s = sin(angle);',
'    float c = cos(angle);',
'    float oc = 1.0 - c;',
'    ',
'    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,',
'                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,',
'                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,',
'                0.0,                                0.0,                                0.0,                                1.0);',
'}',
'mat4 transMatrix(vec3 axis)',
'{',
'    axis = normalize(axis);',
'    ',
'    return mat4(1.0,  0.0,  0.0,  axis.x,',
'                0.0,  1.0,  0.0,  axis.y,',
'                0.0,  0.0,  1.0,  axis.z,',
'                0.0,  0.0,  0.0,  1.0    );',
'}',
// 'uniform vec3 eye;',
'void mainImage3( out vec4 fragColor, in vec2 fragCoord )',
'{	',
'	vec2 q = fragCoord.xy/iResolution.xy;',
'   vec2 p = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;',
'    p = (rotationMatrix(vec3(0.0, 1.0, 0.0), dot(p.xyx,eye.xyz)) * vec4(p.x,p.y,1.0,1.0)).xy;',
'    bsMo = (vec2(0.1,0.2) - 0.5*iResolution.xy)/iResolution.y;',
'    ',
'    float time = 0.0*3.;',
'    vec3 ro = vec3(0,0,time);',
'    ',
'    ro += vec3(sin(0.1)*0.5,sin(0.5*1.)*0.,0);',
'    ro = vec3(1.0,-1.0,1.0);',
'        ',
'    float dspAmp = .25;',
'    ro.xy -= disp(ro.z)*dspAmp;',
'    float tgtDst = .25;',
'    ',
'    vec3 target = normalize(ro - vec3(disp(time + tgtDst)*dspAmp, time + tgtDst));',
'    ro.x -= bsMo.x*2.;',
'    vec3 rightdir = normalize(cross(target, vec3(0.5,0.5,0)));',
'    vec3 updir = normalize(cross(rightdir, target));',
'    rightdir = normalize(cross(updir, target));',
'	vec3 rd=normalize((p.x*rightdir + p.y*updir)*1. - target);',
'    rd.xy *= rot(-disp(time + .5).x*0.8 + bsMo.x);',
'    prm1 = smoothstep(0., 0.8,sin(dot(bsMo,bsMo)*0.3));',
'	vec4 scn = render(ro, rd, time);',
'		',
'    vec3 col = scn.rgb;',
'    col = iLerp(col.bgr, col.rgb, clamp(1.-prm1,0.1,1.));',
'    ',
'    col = pow(col, vec3(.50,.50,.50))*vec3(1.2,1.2,1.20);',
'    vec3 colo = vec3(1.0);',
'    colo *= pow( .820*q.x*q.y*(1.0-q.x)*(1.0-q.y), 1.5212)*5.952+0.4512193; //Vign',
'    col = colo + col;',
'    //col = clamp(col,0.0,0.8);',
'    //col += vec3(0.2,0.2,0.2);',
'	fragColor = vec4( col, 1.0 );',
'}',

'void main() {',
'  // pixel color',
'  //vec3 col = render(ro, rd);',
'  vec4 col,col2;',
'  vec3 color;',
// '  vec3 d = (rotationMatrix(vec3(0.0, 1.0, 0.0), 2.0*3.14) * vec4(gl_FragCoord.xyz,1.0)).xyz;',
'  mainImage2( col, gl_FragCoord.xy );',
'  mainImage( col2, gl_FragCoord.xy );',
'  color = clamp(col.xyz, 0.0,0.95);',
'  color = mix(col2.xyz, color.xyz,.160);',
// '  color = col2.xyz;',

'  color = pow(color, vec3(1.245));',
' vec3 normal = normalize( vNormal);',
' vec3 lightdir = normalize(vec4(0.0,0.0,-10000000000.0,1.0)-gl_FragCoord).xyz;',
' float dif = max(dot(normal, lightdir), 0.0);',
	// specular lighting
	'float specularLight = 0.50f;',
	'vec3 viewDirection = normalize(eye - gl_FragCoord.xyz);',
	'vec3 reflectionDirection = reflect(lightdir, normal);',
	'float specAmount = pow(max(dot(viewDirection, reflectionDirection), 0.0f), 8.0);',
'   float specular = specAmount * specularLight;',
'if(dot(normal, lightdir)>0.0)',
'{',
    ' color = color * vec3(1.0) * (dif+0.2+specular);',
'}',
'else',
' color = color * vec3(1.0) * (0.0+0.2+0.0);',
'  mainImage5( col, gl_FragCoord.xy );',
'  color *=mix(col.xyz, color.xyz,.560);',
' color = clamp(color, vec3(0.0),vec3(1.0));',
// ' color *= pow( 0.220, 1.5212)*5.952+0.4512193; //Vign',

// 'if(color != vec3(1.0) && color.b > vec3(1.0).b  && color.r > vec3(1.0).r && color.g > vec3(0.50).g)',
// '{',
//     ' color = color * vec3(0.50,0.50,8.0) * (dif+0.01+specular);',
// '}',
// 'if(color != vec3(1.0) && color.b > vec3(8.0).b && color.b < vec3(9.0).b  && color.r > vec3(1.0).r && color.g > vec3(0.80).g)',
// '{',
//     ' color = color * vec3(0.50,0.0,.0) * (dif+0.21+specular);',
// '}',
'  gl_FragColor = vec4(color, 1.0);',
'}',

    ]).join('\n'),
    uniforms : {
        "iResolution" : {value : new Vector3()},
        "iTime" : {value : 0.0,type: "f"},
        "fov" : {value : 75},
        "iMouse" : {value : new Vector2()},
        "eye" : {value : new Vector3()},
        "center" : {value : new Vector3()},
        "alpha1" : {value : 0.38,type: "f"},
        "alpha2" : {value : 0.23,type: "f"},
        "alpha3" :{value : 0.22,type: "f"},
        "alpha4" : {value : 0.21,type: "f"},
        // "alpha1" : {value : 0.50,type: "f"},
        // "alpha2" : {value : 0.23,type: "f"},
        // "alpha3" :{value : 0.16,type: "f"},
        // "alpha4" : {value : 0.50,type: "f"},
        "alpha5" : {value : 0.0,type: "f"},
        // "mouse" : {value: new Vector2()},
    }
}

export var M_opal = new ShaderMaterial({
    vertexShader: opalShader.vertexShader,
    fragmentShader:opalShader.fragmentShader,
    uniforms:opalShader.uniforms,
});

